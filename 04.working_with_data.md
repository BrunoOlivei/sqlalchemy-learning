# Trabalhando com dados

## Usando a instrução INSERT

Ao usar o Core, assim como ao usar o ORM para operações em massa, uma instrução SQL INSERT é gerada diretamente usando a função `insert()` - esta função gera uma nova instância de `Insert` que representa uma instrução INSERT em SQL, que adiciona novos dados a uma tabela.

### A construção da expressão SQL `insert()`

Um exemplo simples do `Insert` é ilustrado declarando a tabela a ser usada e, em seguida, passando os valores a serem inseridos para a função `insert()`:

```python
from sqlalchemy import insert

insert_stmt = insert(user_table).values(name='spongebob', fullname='Spongebob Squarepants')
```

A maioria das expressões SQL pode ser transformada em strings no próprio local como uma maneira de visualizar a forma geral do que está sendo produzido:

```python
print(insert_stmt)
```

```sql
INSERT INTO user (name, fullname) VALUES (:name, :fullname)
```

Aqui, o `Insert` é um objeto que representa uma instrução SQL INSERT. O objeto `Insert` é criado usando a função `insert()` do módulo `sqlalchemy.sql.expression`. A função `insert()` aceita como argumento a tabela a ser inserida, que é um objeto `Table` criado anteriormente. A função `insert()` retorna um objeto `Insert` que representa uma instrução SQL INSERT.

O objeto `Insert` possui um atributo `values` que é usado para especificar os valores a serem inseridos. O atributo `values` é um objeto `ValuesClause` que representa uma cláusula VALUES em uma instrução INSERT. O objeto `ValuesClause` possui um método `compile()` que retorna um objeto `Compiled` que representa a instrução SQL compilada. O objeto `Compiled` possui um atributo `params` que é um dicionário de parâmetros que contém os valores a serem inseridos.

O objeto `Insert` também possui um método `compile()` que retorna um objeto `Compiled` que representa a instrução SQL compilada. O objeto `Compiled` possui um atributo `params` que é um dicionário de parâmetros que contém os valores a serem inseridos.

```python
print(insert_stmt.compile().params)
```

```python
{'name': 'spongebob', 'fullname': 'Spongebob Squarepants'}
```

### Executando a instrução INSERT

Para executar a instrução INSERT, o objeto `Insert` é passado para o método `execute()` do objeto `Connection`:

```python
with engine.connect() as conn:
    result = conn.execute(insert_stmt)
    conn.commit()
```

O método `execute()` retorna um objeto `ResultProxy` que representa os resultados da instrução. O objeto `ResultProxy` possui um atributo `rowcount` que retorna o número de linhas afetadas pela instrução.

```python
print(result.rowcount)
```

```python
1
```

Também possui o método `inserted_primary_key()` que retorna a chave primária do registro inserido. Isso é útil quando a chave primária é gerada automaticamente, como no caso de uma coluna de chave primária de incremento automático.

```python
print(result.inserted_primary_key)
```

```python
[1]
```

#### Código completo

```python

from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey
from sqlalchemy import insert
from sqlalchemy import create_engine

engine = create_engine('sqlite:///:memory:', echo=True)

metadata_obj = MetaData()


user_table = Table(
    "user_account",
    metadata_obj,
    Column("id", Integer, primary_key=True),
    Column("name", String(30)),
    Column("fullname", String),
)

address_table = Table(
    "address",
    metadata_obj,
    Column("id", Integer, primary_key=True),
    Column("user_id", ForeignKey("user_account.id"), nullable=False),
    Column("email_address", String, nullable=False),
)

metadata_obj.create_all(engine)


insert_stmt = insert(user_table).values(name='spongebob', fullname='Spongebob Squarepants')

with engine.connect() as conn:
    result = conn.execute(insert_stmt)
    conn.commit()

print(result.rowcount)
print(result.inserted_primary_key)
```

```python
1
[1]
```

> [!Note]
> 
> Nesta edição, com o objetivo de ter alguns dados interessantes na tabela address_table também, abaixo está um exemplo mais avançado que ilustra como o método Insert.values() pode ser usado explicitamente ao mesmo tempo que inclui VALORES adicionais gerados dos parâmetros. Uma subquery escalar é construída, fazendo uso do construct select() introduzido na próxima seção, e os parâmetros usados ​​na subquery são configurados usando um nome de parâmetro vinculado explícito, estabelecido usando o construct bindparam().
> 
> Este é um alquimismo um pouco mais profundo para que possamos adicionar linhas relacionadas sem recuperar os identificadores de chave primária da operação user_table para o aplicativo. A maioria dos Alquimistas simplesmente usará o ORM que cuida de coisas assim para nós.
>
> ```python
> from sqlalchemy import select, bindparam
> scalar_subq = (
>     select(user_table.c.id).
>     where(user_table.c.name == bindparam('username'))
>     .scalar_subquery()
> )
> with engine.connect() as conn:
>     result = conn.execute(
>         insert(address_table).values(
>             user_id=scalar_subq,
>         [
>             {'username': 'spongebob',
>              'email_address': 'spongebob@sqlalchemy.org'
>             },
>             {'username': 'sandy',
>              'email_address': 'sandy@sqlalchemy.org'
>             },
>             {'username': 'sandy',
>              'email_address': 'sandy@squirrelpower.org'
>             },
>         ]
>     )
>     conn.commit()
> ```

## INSERT...RETURNING

A expressão RETURNING é suportada por muitos bancos de dados, incluindo PostgreSQL, Oracle, SQL Server e SQLite. A expressão RETURNING permite que o banco de dados retorne valores gerados automaticamente, como valores de chave primária ou valores de coluna de data / hora com valor padrão.

### Usando o método returning()

O método `returning()` é usado para especificar a lista de colunas a serem retornadas. O método `returning()` retorna um objeto `Insert` que representa uma instrução SQL INSERT com uma cláusula RETURNING.

```python
insert_stmt = insert(address_table).returning(
    address_table.c.id, address_table.c.email_address
)
print(insert_stmt)
```

```sql
INSERT INTO address (id, email_address) VALUES (:id, :email_address) RETURNING address.id, address.email_address
```

> [!tip]
> 
> O método `returning()` pode ser usado também com as instruções `update()` e `delete()`.
>

### INSERT...FROM SELECT

Também é possível combinar `insert` com `select`, através do método `Insert.from_select()`, para inserir dados de uma tabela em outra:

```python
select_stmt = select(user_table.c.id, user_table.c.name + "@aol.com")
insert_stmt = insert(address_table).from_select(
    ["user_id", "email_address"], select_stmt
)
print(insert_stmt.returning(address_table.c.id, address_table.c.email_address))
```

```sql
INSERT INTO address (user_id, email_address) SELECT user.id, user.name || :name_1 AS anon_1 FROM user RETURNING address.id, address.email_address
```

## Usando a instrução SELECT

Para o Core e o ORM, a função select() gera um construct Select que é usado para todas as consultas SELECT. Passada para métodos como Connection.execute() no Core e Session.execute() no ORM, uma instrução SELECT é emitida na transação atual e as linhas de resultado estão disponíveis por meio do objeto Result retornado.

### O construct SQL de expressão `select()`

O construct select() constrói uma declaração da mesma forma que o insert(), usando uma abordagem generativa em que cada método constrói mais estado no objeto. Como os outros constructs SQL, ele pode ser formatado em string no local:

```python
from sqlalchemy import select
stms = select(user_table).where(user_table.c.name == 'spongebob')
print(stms)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1
```

```python
with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(row)
```

```python
(1, 'spongebob', 'Spongebob Squarepants')
```

Usando o ORM:

```python
with Session(engine) as session:
    for row in session.execute(stmt):
        print(row)
```

```python
(1, 'spongebob', 'Spongebob Squarepants')
```


### Definindo as cláusulas COLUMNS e FROM

O construct select() aceita uma lista de objetos Column como argumento, que é o equivalente a listar as colunas na cláusula SELECT. Se nenhuma lista de colunas for fornecida, todas as colunas da tabela serão selecionadas. O objeto Column é criado anteriormente usando o objeto Table.

```python	
from sqlalchemy import select
print(select(user_table))
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
```

```python
from sqlalchemy import select

stmt = select([user_table.c.name, user_table.c.fullname])
print(stmt)
```

```sql
SELECT user.name, user.fullname
FROM user
```

O construct select() também aceita um objeto Table como argumento, que é o equivalente a listar a tabela na cláusula FROM. Se nenhuma tabela for fornecida, a tabela será derivada das colunas especificadas.

```python
from sqlalchemy import select
print(select([user_table]))
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
```

```python
from sqlalchemy import select
print(select(user_table.c["name", "fullname"]))
```

```sql
SELECT user.name, user.fullname
FROM user
```

## Selecionando entidades e colunas ORM

Entidades ORM, como nossa classe User, bem como os atributos mapeados para colunas nela, como User.name, também participam do sistema de linguagem de expressão SQL representando tabelas e colunas

```python
print(select(User))
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
```

```python
print(select(User.name, User.fullname))
```

```sql
SELECT user.name, user.fullname
FROM user
```

Ao executar uma declaração como a acima usando o método Session.execute() do ORM, há uma diferença importante quando selecionamos de uma entidade completa como User, em oposição a user_table, que é que a própria entidade é retornada como um único elemento dentro de cada linha. Isso significa que, quando recuperamos linhas da declaração acima, como há apenas a entidade User na lista de coisas a serem recuperadas, obtemos objetos Row que têm apenas um elemento, que contêm instâncias da classe User:

```python
with Session(engine) as session:
    for row in session.execute(select(User)):
        print(row)
```

```python
<User(id=1, name='spongebob', fullname='Spongebob Squarepants')>
```

```python
with Session(engine) as session:
    for row in session.execute(select(User.name, User.fullname)):
        print(row)
```

```python
('spongebob', 'Spongebob Squarepants')
```

```python
with Session(engine) as session:
    for row in session.execute(select(User)).first():
        print(row)
```

```python
(1, 'spongebob', 'Spongebob Squarepants')
```

Um método de conveniência altamente recomendado para obter o mesmo resultado acima é usar o método Session.scalars() para executar a declaração diretamente; este método retornará um objeto ScalarResult que fornece a primeira “coluna” de cada linha de uma vez, neste caso, instâncias da classe User:

```python
with Session(engine) as session:
    for user in session.scalars(select(User)):
        print(user)
```

```python
<User(id=1, name='spongebob', fullname='Spongebob Squarepants')>
```

Alternativamente podemos selecionar apenas as colunas que queremos:

```python
with Session(engine) as session:
    for name, fullname in session.scalars(select(User.name, User.fullname)):
        print(name, fullname)
```

```python
'spongebob', 'Spongebob Squarepants'
```

### Selecionando de Expressões SQL com Rótulos

O método ColumnElement.label() e o método de mesmo nome disponível nos atributos ORM fornecem um rótulo SQL de uma coluna ou expressão, permitindo que ela tenha um nome específico em um conjunto de resultados. Isso pode ser útil ao se referir a expressões SQL arbitrárias em uma linha de resultado por nome:

```python
from sqlalchemy import select, func

stmt = select(
    "Username": + user_table.c.name).label("username"),
).order_by(user_table.c.name)

with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(f"{row.username}")
```

```python
Username: sandy
Username: spongebob
```

### Selecionando com Expressões de Coluna Textuais

Às vezes também é necessário fabricar blocos de SQL arbitrários dentro de declarações, como expressões de string constante ou apenas algum SQL arbitrário que seja mais rápido de escrever literalmente.

O construct `text()` introduzido em Trabalhando com Transações e o DBAPI pode, na verdade, ser incorporado diretamente em um construct `Select`, como abaixo, onde fabricamos uma literal de string codificada `'some phrase'` e a incorporamos na instrução SELECT:

```python
from sqlalchemy import select, text

stmt = select(
    text("'some phrase'"), user_table.c.name
).order_by(user_table.c.name)

with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(row)
```

```python
('some phrase', 'sandy')
('some phrase', 'spongebob')
```

O método `literal_column()` é muito similar ao `text()` mas é usado para expressões que são apenas colunas, e não expressões arbitrárias:

```python
from sqlalchemy import select, literal_column

stmt = select(
    literal_column("'some phrase'").label("p"), user_table.c.name
).order_by(user_table.c.name)

with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(f"{row.p}, {row.name}")
```

```python
some phrase, sandy
some phrase, spongebob
```

## A cláusula WHERE

A cláusula WHERE é usada para filtrar registros. A cláusula WHERE é especificada usando o método where() do objeto Select. O método where() aceita uma expressão booleana como argumento. O método where() retorna um objeto Select que representa uma instrução SELECT com uma cláusula WHERE.

```python
from sqlalchemy import select

stmt = select(user_table).where(user_table.c.name == 'spongebob')

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1
```

É possível combinar o método `where()` de forma que se comportara como o operador `AND`:

```python
from sqlalchemy import select

stmt = select(user_table).where(
    user_table.c.name == 'spongebob'
).where(
    user_table.c.fullname == 'Spongebob Squarepants'
)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1 AND user.fullname = :fullname_1
```

Uma expressão única `where()` aceita multiplos argumentos e possuem o mesmo efeito:

```python
from sqlalchemy import select

stmt = select(user_table).where(
    user_table.c.name == 'spongebob',
    user_table.c.fullname == 'Spongebob Squarepants'
)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1 AND user.fullname = :fullname_1
```

As cláusulas AND e OR também estão disponíveis como métodos:

```python
from sqlalchemy import select, and_, or_

stmt = select(user_table).where(
    and_(
        or_(
            user_table.c.name == 'spongebob',
            user_table.c.name == 'sandy'
        ),
        Address.user_id == User.id,
        )
    )

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user, address
WHERE (user.name = :name_1 OR user.name = :name_2) AND address.user_id = user.id
```

## Clausulas FROM e JOINs

A cláusula FROM é geralmente inferida com base nas expressões que estamos definindo na cláusula COLUMNS, bem como em outros elementos do Select.

Se definirmos uma única coluna de uma tabela específica na cláusula COLUMNS, ela também colocará essa tabela na cláusula FROM:

```python
from sqlalchemy import select

stmt = select(user_table.c.name)

print(stmt)
```

```sql
SELECT user.name
FROM user
```

Se definirmos uma coluna de uma tabela e uma coluna de outra tabela, ambas as tabelas serão colocadas na cláusula FROM:

```python
from sqlalchemy import select

stmt = select(user_table.c.name, address_table.c.email_address)

print(stmt)
```

```sql
SELECT user.name, address.email_address
FROM user, address
```

Para JOIN essas duas tabelas, normalmente usamos um dos dois métodos no Select. O primeiro é o método Select.join_from(), que nos permite indicar explicitamente o lado esquerdo e direito do JOIN:

```python
from sqlalchemy import select

stmt = select(user_table.c.name, address_table.c.email_address).join_from(
    user_table, address_table
)

print(stmt)
```

```sql
SELECT user.name, address.email_address
FROM user JOIN address ON user.id = address.user_id
```

Outro exemplo em que podemos querer usar `Select.select_from()` é se nossa cláusula de colunas não tiver informações suficientes para fornecer uma cláusula FROM. Por exemplo, para selecionar da expressão SQL comum `count(*)`, usamos um elemento SQLAlchemy conhecido como sqlalchemy.sql.expression.func para produzir a função SQL `count()`:

```python
from sqlalchemy import select, func

stmt = select(func.count("*")).select_from(user_table)

print(stmt)
```

```sql
SELECT count(:count_1) AS count_1
FROM user
```

## Definindo a cláusula ON

Se os alvos esquerdo e direito da junção não tiverem uma *constraint*, ou se houver várias *constraints* em vigor, precisamos especificar a cláusula ON diretamente. Tanto `Select.join()` quanto `Select.join_from()` aceitam um argumento adicional para a cláusula ON, que é declarado usando a mesma mecânica de expressão SQL que vimos na cláusula WHERE.

```python
from sqlalchemy import select

stmt = select(
    address_table.c.email_address
    ).select_from(
        user_table
        ).join(
            address_table,
            user_table.c.id == address_table.c.user_id
        )

print(stmt)
```

```sql
SELECT address.email_address
FROM user JOIN address ON user.id = address.user_id
```

## OUTER e FULL join

Ambos os métodos `Select.join()` e `Select.join_from()` aceitam argumentos de palavra-chave `Select.join.isouter` e `Select.join.full`, que renderizarão LEFT OUTER JOIN e FULL OUTER JOIN, respectivamente.

Um LEFT OUTER JOIN retorna todas as linhas da tabela esquerda, bem como as linhas da tabela direita que correspondem a linhas na tabela esquerda. Um FULL OUTER JOIN retorna todas as linhas das duas tabelas, incluindo linhas que não têm correspondência na outra tabela.

```python
stmt = select(user_table).join(address_table, isouter=True)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user LEFT OUTER JOIN address ON user.id = address.user_id
```

```python
stmt = select(user_table).join(address_table, full=True)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user FULL OUTER JOIN address ON user.id = address.user_id
```

> [!Tip]
> SQL também tem um "RIGHT OUTER JOIN". SQLAlchemy não renderiza isso diretamente; em vez disso, inverta a ordem das tabelas e use "LEFT OUTER JOIN".
>

## ORDER BY, GROUP BY, HAVING

A cláusula ORDER BY é usada para classificar as linhas de uma consulta. A ordem de classificação pode ser ascendente ou descendente. As colunas a serem classificadas são especificadas na cláusula ORDER BY.

A cláusula ORDER BY é construída em termos de construções de expressões SQL, tipicamente baseadas em colunas ou objetos semelhantes. O método `Select.order_by()` aceita uma ou mais dessas expressões de forma posicional.

```python
from sqlalchemy import select

stmt = select(user_table).order_by(user_table.c.name)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user ORDER BY user.name
```

Ordenar crescente ou decrescente é especificado usando o método `asc()` ou `desc()`:

```python
from sqlalchemy import select

stmt = select(user_table).order_by(user_table.c.name.desc())

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user ORDER BY user.name DESC
```

A cláusula GROUP BY é usada para agrupar as linhas de uma consulta. As linhas são agrupadas de acordo com os valores de uma ou mais colunas. As funções de agregação podem ser aplicadas a cada grupo.

O SQLAlchemy permite funções SQL de maneira aberta usando um espaço de nomes conhecido como `func`. Este é um objeto construtor especial que criará novas instâncias de `Function` quando fornecido o nome de uma determinada função SQL, que pode ter qualquer nome, bem como zero ou mais argumentos para passar para a função, que são, como em todos os outros casos, construções de Expressões SQL. Por exemplo, para executar a função SQL COUNT() na coluna `user_account.id`, invocamos o nome `count()`.

```python
from sqlalchemy import func

count_fn = func.count(user_table.c.id)

print(count_fn)
```

```python
count(user_account.id)
```

A cláusula HAVING é usada para filtrar os grupos resultantes da cláusula GROUP BY. A cláusula HAVING especifica uma condição que deve ser satisfeita para que um grupo seja incluído nos resultados da consulta.

O SQLAlchemy permite os métodos `Select.group_by()` e `Select.having()`. Abaixo, ilustramos a seleção de campos de nome de usuário, bem como a contagem de endereços, para aqueles usuários que têm mais de um endereço:

```python
with engine.connect() as conn:
    result = conn.execute(
        select(User.name, func.count(Address.id).label("count"))
        .join(Address)
        .group_by(User.name)
        .having(func.count(Address.id) > 1)
    )
    print(result.all())
```

```python
[('sandy', 2)]
```

```sql
SELECT user.name, count(address.id) AS count
FROM user JOIN address ON user.id = address.user_id
GROUP BY user.name
HAVING count(address.id) > :count_1
```

## Ordenar ou Agrupar por um Rótulo

Uma técnica importante, particularmente em alguns bancos de dados, é a capacidade de ORDENAR POR ou AGRUPAR POR uma expressão que já foi declarada na cláusula de colunas, sem declarar novamente a expressão na cláusula ORDER BY ou GROUP BY e, em vez disso, usando o nome da coluna ou o nome rotulado da cláusula de COLUNAS. Essa forma está disponível passando o texto da string com o nome para o método `Select.order_by()` ou `Select.group_by()`. O texto passado não é renderizado diretamente; em vez disso, o nome dado a uma expressão na cláusula de colunas é renderizado como esse nome de expressão no contexto, gerando um erro se nenhuma correspondência for encontrada. Os modificadores unários `asc()` e `desc()` também podem ser usados nessa forma.

```python
from sqlalchemy import func, desc
stmt = (
    select(Address.user_id, func.count(Address.id).label("num_addresses"))
    .group_by("user_id")
    .order_by("user_id", desc("num_addresses"))
)
print(stmt)
```

```sql
SELECT address.user_id, count(address.id) AS num_addresses
FROM address GROUP BY address.user_id ORDER BY address.user_id, num_addresses DESC
```

## Usando aliases

Agora que estamos selecionando de várias tabelas e usando junções, rapidamente nos deparamos com o caso em que precisamos nos referir à mesma tabela várias vezes na cláusula FROM de uma instrução. Conseguimos fazer isso usando **aliases** SQL, que são uma sintaxe que fornece um nome alternativo para uma tabela ou subconsulta pela qual ela pode ser referenciada na instrução.

Na Linguagem de Expressão do SQLAlchemy, esses "nomes" são representados por objetos `FromClause` conhecidos como a construção `Alias`, que é construída no Core usando o método `FromClause.alias()`. Uma construção `Alias` é semelhante a uma construção `Table`, pois também possui um espaço de nomes de objetos `Column` na coleção `Alias.c`. A instrução SELECT abaixo, por exemplo, retorna todos os pares únicos de nomes de usuário:

```python
user_alias_1 = user_table.alias()
user_alias_2 = user_table.alias()
print(
    select(user_alias_1.c.name, user_alias_2.c.name).join_from(
        user_alias_1, user_alias_2, user_alias_1.c.id > user_alias_2.c.id
    )
)
```

```sql
SELECT user_account_1.name, user_account_2.name AS name_1
FROM user_account AS user_account_1
JOIN user_account AS user_account_2 ON user_account_1.id > user_account_2.id
```

## Aliases de entidade ORM

O equivalente ORM do método `FromClause.alias()` é a função `aliased()` do ORM, que pode ser aplicada a uma entidade como User e Address. Isso produz internamente um objeto `Alias` em relação ao objeto de Tabela original mapeado, mantendo a funcionalidade ORM. 

```python
from sqlalchemy.orm import aliased
address_alias_1 = aliased(Address)
address_alias_2 = aliased(Address)
print(
    select(User)
    .join_from(User, address_alias_1)
    .where(address_alias_1.email_address == "patrick@aol.com")
    .join_from(User, address_alias_2)
    .where(address_alias_2.email_address == "patrick@gmail.com")
)
```

```sql
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
JOIN address AS address_1 ON user_account.id = address_1.user_id
JOIN address AS address_2 ON user_account.id = address_2.user_id
WHERE address_1.email_address = :email_address_1
AND address_2.email_address = :email_address_2
```

## Subconsultas e CTEs (Expressões de Tabela Comuns)

Uma subconsulta em SQL é uma instrução SELECT que é colocada entre parênteses e inserida no contexto de uma instrução de envolvimento, geralmente uma instrução SELECT, mas nem sempre.

Esta seção abordará uma subconsulta chamada "não escalar", que normalmente é colocada na cláusula FROM de uma instrução SELECT de envolvimento. Também abordaremos a Expressão de Tabela Comum, ou CTE, que é usada de maneira semelhante a uma subconsulta, mas inclui recursos adicionais.

O SQLAlchemy usa o objeto `Subquery` para representar uma subconsulta e o CTE para representar uma CTE, geralmente obtidos pelos métodos `Select.subquery()` e `Select.cte()`, respectivamente. Ambos os objetos podem ser usados como um elemento FROM dentro de uma construção `select()` maior.

Podemos construir uma `Subquery` que selecionará uma contagem agregada de linhas da tabela de endereços:

```python
subq = (
    select(func.count(address_table.c.id).label("count"), address_table.c.user_id)
    .group_by(address_table.c.user_id)
    .subquery()
)
print(subq)
```

```sql
SELECT count(address.id) AS count, address.user_id
FROM address GROUP BY address.user_id
```

O objeto `Subquery` se comporta como qualquer outro objeto FROM, como uma `Table`, notavelmente porque inclui um namespace `Subquery.c` das colunas que ele seleciona. Podemos usar esse namespace para nos referirmos tanto à coluna `user_id` quanto à nossa expressão de contagem rotulada personalizada:

```python
print(select(subq.c.user_id, subq.c.count))
```

```sql
SELECT 
    anon_1.user_id,
    anon_1.count
FROM 
    (
        SELECT 
            count(address.id) AS count,
            address.user_id AS user_id
        FROM 
            address 
        GROUP BY 
            address.user_id
    ) AS anon_1
```

Podemos utilizar o `join_from()` para juntar a subconsulta com a tabela de usuários:

```python
stmt = select(user_table.c.name, user_table.c.fullname, subq.c.count).join_from(
    user_table, subq
)

print(stmt)
```

```sql
SELECT 
    user_account.name, 
    user_account.fullname, 
    anon_1.count
FROM 
    user_account 
JOIN 
    (
        SELECT 
            count(address.id) AS count, 
            address.user_id AS user_id
        FROM 
            address 
        GROUP BY 
            address.user_id
        ) AS anon_1 
ON 
    user_account.id = anon_1.user_id
```

Para realizar a junção entre user_account e address, utilizamos o método `Select.join_from()`. Como já foi ilustrado anteriormente, a cláusula ON dessa junção foi inferida novamente com base nas restrições de chave estrangeira. Mesmo que uma subconsulta SQL em si não tenha nenhuma restrição, o SQLAlchemy pode atuar com base nas restrições representadas nas colunas, determinando que a coluna `subq.c.user_id` é derivada da coluna `address_table.c.user_id`, que expressa um relacionamento de chave estrangeira de volta para a coluna `user_table.c.id`, que é então usada para gerar a cláusula ON.

## Expressões de tabela comuns (CTEs)

O uso da construção `CTE` no SQLAlchemy é praticamente o mesmo que o uso da construção `Subquery`. Ao alterar a invocação do método `Select.subquery()` para usar `Select.cte()` em vez disso, podemos usar o objeto resultante como um elemento FROM da mesma maneira, mas o SQL gerado é a sintaxe de expressão de tabela comum, que é bastante diferente:

```python
subq = (
    select(func.count(address_table.c.id).label("count"), address_table.c.user_id)
    .group_by(address_table.c.user_id)
    .cte()
)

stmt = select(user_table.c.name, user_table.c.fullname, subq.c.count).join_from(
    user_table, subq
)

print(stmt)
```

```sql
WITH 
    anon_1 AS (
        SELECT 
            count(address.id) AS count,
            address.user_id AS user_id
        FROM 
            address 
        GROUP BY 
            address.user_id
        )
 SELECT 
    user_account.name,
    user_account.fullname,
    anon_1.count
FROM 
    user_account 
JOIN 
    anon_1 
ON 
    user_account.id = anon_1.user_id
```

Subconsultas/CTEs de Entidades ORM

No ORM, a construção `aliased()` pode ser usada para associar uma entidade ORM, como nossa classe `User` ou `Address`, a qualquer conceito `FromClause` que represente uma fonte de linhas. A seção anterior, "Aliases de Entidades ORM", ilustra o uso de `aliased()` para associar a classe mapeada a um `Alias` de sua `Table` mapeada. Aqui ilustramos o uso do `aliased()` fazendo a mesma associação tanto a uma `Subquery` quanto a uma `CTE` gerada a partir de uma construção `Select`, que em última instância deriva da mesma `Table` mapeada.

Abaixo, temos um exemplo de aplicação do `aliased()` à construção `Subquery`, para que as entidades ORM possam ser extraídas de suas linhas. O resultado mostra uma série de objetos `User` e `Address`, onde os dados para cada objeto `Address` vieram de uma subconsulta contra a tabela `address` e não diretamente daquela tabela:

O ORM também suporta subconsultas e CTEs, embora a sintaxe seja um pouco diferente. Para criar uma subconsulta ORM, usamos o método `Query.subquery()`:

```python
subq = select(Address).where(~Address.email_address.like("%@aol.com")).subquery()
address_subq = aliased(Address, subq)
stmt = (
    select(User, address_subq)
    .join_from(User, address_subq)
    .order_by(User.id, address_subq.id)
)
with Session(engine) as session:
    for user, address in session.execute(stmt):
        print(f"{user} {address}")
```

```python
User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
```

```sql
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname,
    anon_1.id AS id_1,
    anon_1.email_address,
    anon_1.user_id
FROM 
    user_account JOIN (
        SELECT 
            address.id AS id,
            address.email_address AS email_address,
            address.user_id AS user_id
        FROM 
            address
        WHERE 
            address.email_address NOT LIKE '%@aol.com'
        ) AS anon_1 
ON 
    user_account.id = anon_1.user_id
ORDER BY 
    user_account.id,
    anon_1.id
```

Outro exemplo utilizando CTEs:

```python
cte_obj = select(Address).where(~Address.email_address.like("%@aol.com")).cte()
address_cte = aliased(Address, cte_obj)
stmt = (
    select(User, address_cte)
    .join_from(User, address_cte)
    .order_by(User.id, address_cte.id)
)
with Session(engine) as session:
    for user, address in session.execute(stmt):
        print(f"{user} {address}")
```

```python
User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
```

```sql
WITH 
    anon_1 AS (
        SELECT 
            address.id AS id,
            address.email_address AS email_address,
            address.user_id AS user_id
        FROM 
            address
        WHERE 
            address.email_address NOT LIKE ?
        )
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname,
    anon_1.id AS id_1,
    anon_1.email_address,
    anon_1.user_id
FROM 
    user_account
JOIN 
    anon_1
ON 
    user_account.id = anon_1.user_id
ORDER BY 
    user_account.id,
    anon_1.id
```

Subconsultas Escalares e Correlacionadas

Uma subconsulta é uma consulta SQL que é usada dentro de outra consulta. Subconsultas podem ser usadas para uma variedade de propósitos, incluindo:

* Selecionar dados de uma tabela baseada nos resultados de outra consulta
* Filtrar linhas com base nos resultados de outra consulta
* Agrupar linhas com base nos resultados de outra consulta

Existem dois tipos principais de subconsultas: subconsultas escalares e subconsultas correlacionadas.

**Subconsultas Escalares**

Uma subconsulta escalar é uma subconsulta que retorna um único valor. Subconsultas escalares podem ser usadas na cláusula SELECT, na cláusula WHERE, na cláusula GROUP BY e na cláusula HAVING.

Por exemplo, a seguinte consulta usa uma subconsulta escalar na cláusula SELECT para selecionar o nome do funcionário que tem o maior salário:

```sql
SELECT name
FROM employees
WHERE salary = (
    SELECT MAX(salary)
    FROM employees
);
```

Nesta consulta, a subconsulta escalar retorna o valor máximo da coluna `salary` da tabela `employees`. A consulta externa usa este valor para selecionar o funcionário com o salário mais alto.

**Subconsultas Correlacionadas**

Uma subconsulta correlacionada é uma subconsulta que faz referência a uma variável ou expressão de uma consulta externa. Subconsultas correlacionadas podem ser usadas para uma variedade de propósitos, incluindo:

* Filtrar linhas com base nos resultados de uma consulta externa
* Agrupar linhas com base nos resultados de uma consulta externa

Por exemplo, a seguinte consulta usa uma subconsulta correlacionada na cláusula WHERE para selecionar todos os clientes que moram no mesmo estado que seu representante de vendas:

```sql
SELECT *
FROM customers
WHERE state = (
    SELECT state
    FROM representatives
    WHERE representatives.id = customers.representative_id
);
```

Nesta consulta, a subconsulta correlacionada retorna o estado do representante de vendas de cada cliente. A consulta externa usa este valor para selecionar os clientes que moram no mesmo estado que seu representante de vendas.

A principal diferença entre subconsultas escalares e correlacionadas é que subconsultas escalares são avaliadas uma vez, enquanto subconsultas correlacionadas são avaliadas uma vez para cada linha na consulta externa.

O SQLAlchemy representa a subconsulta escalar usando a construção ScalarSelect, que faz parte da hierarquia de expressões `ColumnElement`, em contraste com a subconsulta regular, que é representada pela construção `Subquery`, presente na hierarquia de `FromClause`.

As subconsultas escalares são frequentemente, mas nem sempre, usadas com funções de agregação. Uma subconsulta escalar é indicada explicitamente pelo uso do método `Select.scalar_subquery()` como abaixo. Sua forma de string padrão, quando convertida em string por si só, é renderizada como uma instrução SELECT comum que está selecionando de duas tabelas:

```python
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .scalar_subquery()
)
print(subq)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
)
```

O objeto `subq` acima agora faz parte da hierarquia de expressões SQL `ColumnElement`, de forma que ele pode ser usado como qualquer outra expressão de coluna:

```python
print(subq == 5)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
) = :param_1
```

```python
print(subq > 5)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
) > :param_1
```

```python
print(subq + 5)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
) + :param_1
```

Embora a subconsulta escalar, por si só, renderize tanto `user_account` quanto `address` em sua cláusula FROM quando convertida em string, ao incorporá-la em uma construção `select()` de envolvimento que lida com a tabela `user_account`, a tabela `user_account` é automaticamente correlacionada, o que significa que ela não é renderizada na cláusula FROM da subconsulta:

```python
stmt = select(user_table.c.name, subq.label("address_count"))
print(stmt)
```

```sql
SELECT 
    user_account.name,
    (
        SELECT
        count(address.id) AS count_1
        FROM 
            address
        WHERE 
            user_account.id = address.user_id
    ) AS address_count
FROM
    user_account
```

Subconsultas correlacionadas simples geralmente farão o que é desejado. No entanto, no caso em que a correlação for ambígua, o SQLAlchemy nos informará que é necessária mais clareza:

```python
stmt = (
    select(
        user_table.c.name,
        address_table.c.email_address,
        subq.label("address_count"),
    )
    .join_from(user_table, address_table)
    .order_by(user_table.c.id, address_table.c.id)
)
print(stmt)
```

```bash
Traceback (most recent call last):

InvalidRequestError: Select statement '<... Select object at ...>' returned
no FROM clauses due to auto-correlation; specify correlate(<tables>) to
control correlation manually.
```

Para especificar que a tabela `user_table` é a que desejamos correlacionar, fazemos isso usando os métodos `ScalarSelect.correlate()` ou `ScalarSelect.correlate_except()`:

```python
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .scalar_subquery()
    .correlate(user_table)
)

stmt = (
    select(
        user_table.c.name,
        address_table.c.email_address,
        subq.label("address_count"),
    )
    .join_from(user_table, address_table)
    .order_by(user_table.c.id, address_table.c.id)
)

print(stmt)
```

```sql
SELECT 
    user_account.name,
    address.email_address,
    (
        SELECT
        count(address.id) AS count_1
        FROM 
            address
        WHERE 
            user_account.id = address.user_id
    ) AS address_count
FROM
    user_account 
JOIN 
    address
ON 
    user_account.id = address.user_id
ORDER BY
    user_account.id,
    address.id
```

```python
[
    ('spongebob', 'spongebob@sqlalchemy.org', 1),
    ('sandy', 'sandy@sqlalchemy.org', 2),
    ('sandy', 'sandy@squirrelpower.org', 2)
]
```

## Correlação LATERAL

A correlação LATERAL é uma forma de correlação que permite que você consulte dados de uma tabela relacionada sem usar uma subconsulta correlacionada. A correlação LATERAL é mais eficiente do que as subconsultas correlacionadas, pois não precisa avaliar a subconsulta para cada linha na consulta externa.

A correlação LATERAL é declarada usando a cláusula LATERAL. A cláusula LATERAL é seguida por uma subconsulta que retorna uma tabela. A consulta externa pode então consultar a tabela retornada pela subconsulta LATERAL.

Por exemplo, a seguinte consulta usa a correlação LATERAL para selecionar todos os clientes e seus representantes de vendas:

```sql
SELECT c.name, r.name
FROM customers c
LATERAL (
    SELECT name
    FROM representatives
    WHERE representatives.id = c.representative_id
);
```

Nesta consulta, a subconsulta LATERAL retorna uma tabela com uma coluna chamada `name`. A consulta externa consulta esta tabela para obter o nome do representante de vendas de cada cliente.

A correlação LATERAL é uma ferramenta poderosa que pode ser usada para simplificar consultas SQL.

Não, a consulta lateral não é suportada por todos os bancos de dados SQL. Os bancos de dados SQL mais populares que suportam a consulta lateral incluem:

* MySQL
* PostgreSQL
* Oracle
* SQL Server

Alguns bancos de dados SQL mais antigos, como o SQL Server 2000, não suportam a consulta lateral.

A consulta lateral é uma funcionalidade relativamente recente no SQL. Foi introduzida pela primeira vez no SQL:2011. A consulta lateral é uma funcionalidade opcional no SQL:2011, o que significa que os bancos de dados SQL não são obrigados a suportá-la. A consulta lateral foi tornada obrigatória no SQL:2016.

O SQLAlchemy representa a correlação LATERAL usando a construção `Lateral`, que faz parte da hierarquia de expressões `FromClause`. A construção `Lateral` é usada como um elemento FROM em uma instrução `select()` de envolvimento, onde a subconsulta é passada para o método `Lateral.select()`:

```python
subq = (
    select(
        func.count(address_table.c.id).label("address_count"),
        address_table.c.email_address,
        address_table.c.user_id,
    )
    .where(user_table.c.id == address_table.c.user_id)
    .lateral()
)
stmt = (
    select(user_table.c.name, subq.c.address_count, subq.c.email_address)
    .join_from(user_table, subq)
    .order_by(user_table.c.id, subq.c.email_address)
)
print(stmt)
```

```sql
SELECT 
    user_account.name,
    anon_1.address_count,
    anon_1.email_address
FROM
    user_account
JOIN LATERAL (
    SELECT 
        count(address.id) AS address_count,
        address.email_address AS email_address,
        address.user_id AS user_id
    FROM 
        address
    WHERE 
        user_account.id = address.user_id
) AS anon_1
ON 
    user_account.id = anon_1.user_id
ORDER BY
    user_account.id,
    anon_1.email_address
```
