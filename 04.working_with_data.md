# Trabalhando com dados

## Usando a instrução INSERT

Ao usar o Core, assim como ao usar o ORM para operações em massa, uma instrução SQL INSERT é gerada diretamente usando a função `insert()` - esta função gera uma nova instância de `Insert` que representa uma instrução INSERT em SQL, que adiciona novos dados a uma tabela.

### A construção da expressão SQL `insert()`

Um exemplo simples do `Insert` é ilustrado declarando a tabela a ser usada e, em seguida, passando os valores a serem inseridos para a função `insert()`:

```python
from sqlalchemy import insert

insert_stmt = insert(user_table).values(name='spongebob', fullname='Spongebob Squarepants')
```

A maioria das expressões SQL pode ser transformada em strings no próprio local como uma maneira de visualizar a forma geral do que está sendo produzido:

```python
print(insert_stmt)
```

```sql
INSERT INTO user (name, fullname) VALUES (:name, :fullname)
```

Aqui, o `Insert` é um objeto que representa uma instrução SQL INSERT. O objeto `Insert` é criado usando a função `insert()` do módulo `sqlalchemy.sql.expression`. A função `insert()` aceita como argumento a tabela a ser inserida, que é um objeto `Table` criado anteriormente. A função `insert()` retorna um objeto `Insert` que representa uma instrução SQL INSERT.

O objeto `Insert` possui um atributo `values` que é usado para especificar os valores a serem inseridos. O atributo `values` é um objeto `ValuesClause` que representa uma cláusula VALUES em uma instrução INSERT. O objeto `ValuesClause` possui um método `compile()` que retorna um objeto `Compiled` que representa a instrução SQL compilada. O objeto `Compiled` possui um atributo `params` que é um dicionário de parâmetros que contém os valores a serem inseridos.

O objeto `Insert` também possui um método `compile()` que retorna um objeto `Compiled` que representa a instrução SQL compilada. O objeto `Compiled` possui um atributo `params` que é um dicionário de parâmetros que contém os valores a serem inseridos.

```python
print(insert_stmt.compile().params)
```

```python
{'name': 'spongebob', 'fullname': 'Spongebob Squarepants'}
```

### Executando a instrução INSERT

Para executar a instrução INSERT, o objeto `Insert` é passado para o método `execute()` do objeto `Connection`:

```python
with engine.connect() as conn:
    result = conn.execute(insert_stmt)
    conn.commit()
```

O método `execute()` retorna um objeto `ResultProxy` que representa os resultados da instrução. O objeto `ResultProxy` possui um atributo `rowcount` que retorna o número de linhas afetadas pela instrução.

```python
print(result.rowcount)
```

```python
1
```

Também possui o método `inserted_primary_key()` que retorna a chave primária do registro inserido. Isso é útil quando a chave primária é gerada automaticamente, como no caso de uma coluna de chave primária de incremento automático.

```python
print(result.inserted_primary_key)
```

```python
[1]
```

#### Código completo

```python

from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey
from sqlalchemy import insert
from sqlalchemy import create_engine

engine = create_engine('sqlite:///:memory:', echo=True)

metadata_obj = MetaData()


user_table = Table(
    "user_account",
    metadata_obj,
    Column("id", Integer, primary_key=True),
    Column("name", String(30)),
    Column("fullname", String),
)

address_table = Table(
    "address",
    metadata_obj,
    Column("id", Integer, primary_key=True),
    Column("user_id", ForeignKey("user_account.id"), nullable=False),
    Column("email_address", String, nullable=False),
)

metadata_obj.create_all(engine)


insert_stmt = insert(user_table).values(name='spongebob', fullname='Spongebob Squarepants')

with engine.connect() as conn:
    result = conn.execute(insert_stmt)
    conn.commit()

print(result.rowcount)
print(result.inserted_primary_key)
```

```python
1
[1]
```

> [!Note]
> 
> Nesta edição, com o objetivo de ter alguns dados interessantes na tabela address_table também, abaixo está um exemplo mais avançado que ilustra como o método Insert.values() pode ser usado explicitamente ao mesmo tempo que inclui VALORES adicionais gerados dos parâmetros. Uma subquery escalar é construída, fazendo uso do construct select() introduzido na próxima seção, e os parâmetros usados ​​na subquery são configurados usando um nome de parâmetro vinculado explícito, estabelecido usando o construct bindparam().
> 
> Este é um alquimismo um pouco mais profundo para que possamos adicionar linhas relacionadas sem recuperar os identificadores de chave primária da operação user_table para o aplicativo. A maioria dos Alquimistas simplesmente usará o ORM que cuida de coisas assim para nós.
>
> ```python
> from sqlalchemy import select, bindparam
> scalar_subq = (
>     select(user_table.c.id).
>     where(user_table.c.name == bindparam('username'))
>     .scalar_subquery()
> )
> with engine.connect() as conn:
>     result = conn.execute(
>         insert(address_table).values(
>             user_id=scalar_subq,
>         [
>             {'username': 'spongebob',
>              'email_address': 'spongebob@sqlalchemy.org'
>             },
>             {'username': 'sandy',
>              'email_address': 'sandy@sqlalchemy.org'
>             },
>             {'username': 'sandy',
>              'email_address': 'sandy@squirrelpower.org'
>             },
>         ]
>     )
>     conn.commit()
> ```

### INSERT...RETURNING

A expressão RETURNING é suportada por muitos bancos de dados, incluindo PostgreSQL, Oracle, SQL Server e SQLite. A expressão RETURNING permite que o banco de dados retorne valores gerados automaticamente, como valores de chave primária ou valores de coluna de data / hora com valor padrão.

#### Usando o método `returning()`

O método `returning()` é usado para especificar a lista de colunas a serem retornadas. O método `returning()` retorna um objeto `Insert` que representa uma instrução SQL INSERT com uma cláusula RETURNING.

```python
insert_stmt = insert(address_table).returning(
    address_table.c.id, address_table.c.email_address
)
print(insert_stmt)
```

```sql
INSERT INTO address (id, email_address) VALUES (:id, :email_address) RETURNING address.id, address.email_address
```

> [!tip]
> 
> O método `returning()` pode ser usado também com as instruções `update()` e `delete()`.
>

### INSERT...FROM SELECT

Também é possível combinar `insert` com `select`, através do método `Insert.from_select()`, para inserir dados de uma tabela em outra:

```python
select_stmt = select(user_table.c.id, user_table.c.name + "@aol.com")
insert_stmt = insert(address_table).from_select(
    ["user_id", "email_address"], select_stmt
)
print(insert_stmt.returning(address_table.c.id, address_table.c.email_address))
```

```sql
INSERT INTO address (user_id, email_address) SELECT user.id, user.name || :name_1 AS anon_1 FROM user RETURNING address.id, address.email_address
```

## Usando a instrução SELECT

Para o Core e o ORM, a função select() gera um construct Select que é usado para todas as consultas SELECT. Passada para métodos como Connection.execute() no Core e Session.execute() no ORM, uma instrução SELECT é emitida na transação atual e as linhas de resultado estão disponíveis por meio do objeto Result retornado.

### O construct SQL de expressão `select()`

O construct select() constrói uma declaração da mesma forma que o insert(), usando uma abordagem generativa em que cada método constrói mais estado no objeto. Como os outros constructs SQL, ele pode ser formatado em string no local:

```python
from sqlalchemy import select
stms = select(user_table).where(user_table.c.name == 'spongebob')
print(stms)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1
```

```python
with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(row)
```

```python
(1, 'spongebob', 'Spongebob Squarepants')
```

Usando o ORM:

```python
with Session(engine) as session:
    for row in session.execute(stmt):
        print(row)
```

```python
(1, 'spongebob', 'Spongebob Squarepants')
```


### Definindo as cláusulas COLUMNS e FROM

O construct select() aceita uma lista de objetos Column como argumento, que é o equivalente a listar as colunas na cláusula SELECT. Se nenhuma lista de colunas for fornecida, todas as colunas da tabela serão selecionadas. O objeto Column é criado anteriormente usando o objeto Table.

```python	
from sqlalchemy import select
print(select(user_table))
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
```

```python
from sqlalchemy import select

stmt = select([user_table.c.name, user_table.c.fullname])
print(stmt)
```

```sql
SELECT user.name, user.fullname
FROM user
```

O construct select() também aceita um objeto Table como argumento, que é o equivalente a listar a tabela na cláusula FROM. Se nenhuma tabela for fornecida, a tabela será derivada das colunas especificadas.

```python
from sqlalchemy import select
print(select([user_table]))
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
```

```python
from sqlalchemy import select
print(select(user_table.c["name", "fullname"]))
```

```sql
SELECT user.name, user.fullname
FROM user
```

### Selecionando entidades e colunas ORM

Entidades ORM, como nossa classe User, bem como os atributos mapeados para colunas nela, como User.name, também participam do sistema de linguagem de expressão SQL representando tabelas e colunas

```python
print(select(User))
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
```

```python
print(select(User.name, User.fullname))
```

```sql
SELECT user.name, user.fullname
FROM user
```

Ao executar uma declaração como a acima usando o método Session.execute() do ORM, há uma diferença importante quando selecionamos de uma entidade completa como User, em oposição a user_table, que é que a própria entidade é retornada como um único elemento dentro de cada linha. Isso significa que, quando recuperamos linhas da declaração acima, como há apenas a entidade User na lista de coisas a serem recuperadas, obtemos objetos Row que têm apenas um elemento, que contêm instâncias da classe User:

```python
with Session(engine) as session:
    for row in session.execute(select(User)):
        print(row)
```

```python
<User(id=1, name='spongebob', fullname='Spongebob Squarepants')>
```

```python
with Session(engine) as session:
    for row in session.execute(select(User.name, User.fullname)):
        print(row)
```

```python
('spongebob', 'Spongebob Squarepants')
```

```python
with Session(engine) as session:
    for row in session.execute(select(User)).first():
        print(row)
```

```python
(1, 'spongebob', 'Spongebob Squarepants')
```

Um método de conveniência altamente recomendado para obter o mesmo resultado acima é usar o método Session.scalars() para executar a declaração diretamente; este método retornará um objeto ScalarResult que fornece a primeira “coluna” de cada linha de uma vez, neste caso, instâncias da classe User:

```python
with Session(engine) as session:
    for user in session.scalars(select(User)):
        print(user)
```

```python
<User(id=1, name='spongebob', fullname='Spongebob Squarepants')>
```

Alternativamente podemos selecionar apenas as colunas que queremos:

```python
with Session(engine) as session:
    for name, fullname in session.scalars(select(User.name, User.fullname)):
        print(name, fullname)
```

```python
'spongebob', 'Spongebob Squarepants'
```

#### Selecionando de Expressões SQL com Rótulos

O método ColumnElement.label() e o método de mesmo nome disponível nos atributos ORM fornecem um rótulo SQL de uma coluna ou expressão, permitindo que ela tenha um nome específico em um conjunto de resultados. Isso pode ser útil ao se referir a expressões SQL arbitrárias em uma linha de resultado por nome:

```python
from sqlalchemy import select, func

stmt = select(
    "Username": + user_table.c.name).label("username"),
).order_by(user_table.c.name)

with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(f"{row.username}")
```

```python
Username: sandy
Username: spongebob
```

#### Selecionando com Expressões de Coluna Textuais

Às vezes também é necessário fabricar blocos de SQL arbitrários dentro de declarações, como expressões de string constante ou apenas algum SQL arbitrário que seja mais rápido de escrever literalmente.

O construct `text()` introduzido em Trabalhando com Transações e o DBAPI pode, na verdade, ser incorporado diretamente em um construct `Select`, como abaixo, onde fabricamos uma literal de string codificada `'some phrase'` e a incorporamos na instrução SELECT:

```python
from sqlalchemy import select, text

stmt = select(
    text("'some phrase'"), user_table.c.name
).order_by(user_table.c.name)

with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(row)
```

```python
('some phrase', 'sandy')
('some phrase', 'spongebob')
```

O método `literal_column()` é muito similar ao `text()` mas é usado para expressões que são apenas colunas, e não expressões arbitrárias:

```python
from sqlalchemy import select, literal_column

stmt = select(
    literal_column("'some phrase'").label("p"), user_table.c.name
).order_by(user_table.c.name)

with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(f"{row.p}, {row.name}")
```

```python
some phrase, sandy
some phrase, spongebob
```

### A cláusula WHERE

A cláusula WHERE é usada para filtrar registros. A cláusula WHERE é especificada usando o método where() do objeto Select. O método where() aceita uma expressão booleana como argumento. O método where() retorna um objeto Select que representa uma instrução SELECT com uma cláusula WHERE.

```python
from sqlalchemy import select

stmt = select(user_table).where(user_table.c.name == 'spongebob')

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1
```

É possível combinar o método `where()` de forma que se comportara como o operador `AND`:

```python
from sqlalchemy import select

stmt = select(user_table).where(
    user_table.c.name == 'spongebob'
).where(
    user_table.c.fullname == 'Spongebob Squarepants'
)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1 AND user.fullname = :fullname_1
```

Uma expressão única `where()` aceita multiplos argumentos e possuem o mesmo efeito:

```python
from sqlalchemy import select

stmt = select(user_table).where(
    user_table.c.name == 'spongebob',
    user_table.c.fullname == 'Spongebob Squarepants'
)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user
WHERE user.name = :name_1 AND user.fullname = :fullname_1
```

As cláusulas AND e OR também estão disponíveis como métodos:

```python
from sqlalchemy import select, and_, or_

stmt = select(user_table).where(
    and_(
        or_(
            user_table.c.name == 'spongebob',
            user_table.c.name == 'sandy'
        ),
        Address.user_id == User.id,
        )
    )

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user, address
WHERE (user.name = :name_1 OR user.name = :name_2) AND address.user_id = user.id
```

### Clausulas FROM e JOINs

A cláusula FROM é geralmente inferida com base nas expressões que estamos definindo na cláusula COLUMNS, bem como em outros elementos do Select.

Se definirmos uma única coluna de uma tabela específica na cláusula COLUMNS, ela também colocará essa tabela na cláusula FROM:

```python
from sqlalchemy import select

stmt = select(user_table.c.name)

print(stmt)
```

```sql
SELECT user.name
FROM user
```

Se definirmos uma coluna de uma tabela e uma coluna de outra tabela, ambas as tabelas serão colocadas na cláusula FROM:

```python
from sqlalchemy import select

stmt = select(user_table.c.name, address_table.c.email_address)

print(stmt)
```

```sql
SELECT user.name, address.email_address
FROM user, address
```

Para JOIN essas duas tabelas, normalmente usamos um dos dois métodos no Select. O primeiro é o método Select.join_from(), que nos permite indicar explicitamente o lado esquerdo e direito do JOIN:

```python
from sqlalchemy import select

stmt = select(user_table.c.name, address_table.c.email_address).join_from(
    user_table, address_table
)

print(stmt)
```

```sql
SELECT user.name, address.email_address
FROM user JOIN address ON user.id = address.user_id
```

Outro exemplo em que podemos querer usar `Select.select_from()` é se nossa cláusula de colunas não tiver informações suficientes para fornecer uma cláusula FROM. Por exemplo, para selecionar da expressão SQL comum `count(*)`, usamos um elemento SQLAlchemy conhecido como sqlalchemy.sql.expression.func para produzir a função SQL `count()`:

```python
from sqlalchemy import select, func

stmt = select(func.count("*")).select_from(user_table)

print(stmt)
```

```sql
SELECT count(:count_1) AS count_1
FROM user
```

### Definindo a cláusula ON

Se os alvos esquerdo e direito da junção não tiverem uma *constraint*, ou se houver várias *constraints* em vigor, precisamos especificar a cláusula ON diretamente. Tanto `Select.join()` quanto `Select.join_from()` aceitam um argumento adicional para a cláusula ON, que é declarado usando a mesma mecânica de expressão SQL que vimos na cláusula WHERE.

```python
from sqlalchemy import select

stmt = select(
    address_table.c.email_address
    ).select_from(
        user_table
        ).join(
            address_table,
            user_table.c.id == address_table.c.user_id
        )

print(stmt)
```

```sql
SELECT address.email_address
FROM user JOIN address ON user.id = address.user_id
```

### OUTER e FULL join

Ambos os métodos `Select.join()` e `Select.join_from()` aceitam argumentos de palavra-chave `Select.join.isouter` e `Select.join.full`, que renderizarão LEFT OUTER JOIN e FULL OUTER JOIN, respectivamente.

Um LEFT OUTER JOIN retorna todas as linhas da tabela esquerda, bem como as linhas da tabela direita que correspondem a linhas na tabela esquerda. Um FULL OUTER JOIN retorna todas as linhas das duas tabelas, incluindo linhas que não têm correspondência na outra tabela.

```python
stmt = select(user_table).join(address_table, isouter=True)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user LEFT OUTER JOIN address ON user.id = address.user_id
```

```python
stmt = select(user_table).join(address_table, full=True)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user FULL OUTER JOIN address ON user.id = address.user_id
```

> [!Tip]
> SQL também tem um "RIGHT OUTER JOIN". SQLAlchemy não renderiza isso diretamente; em vez disso, inverta a ordem das tabelas e use "LEFT OUTER JOIN".
>

### ORDER BY, GROUP BY, HAVING

A cláusula ORDER BY é usada para classificar as linhas de uma consulta. A ordem de classificação pode ser ascendente ou descendente. As colunas a serem classificadas são especificadas na cláusula ORDER BY.

A cláusula ORDER BY é construída em termos de construções de expressões SQL, tipicamente baseadas em colunas ou objetos semelhantes. O método `Select.order_by()` aceita uma ou mais dessas expressões de forma posicional.

```python
from sqlalchemy import select

stmt = select(user_table).order_by(user_table.c.name)

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user ORDER BY user.name
```

Ordenar crescente ou decrescente é especificado usando o método `asc()` ou `desc()`:

```python
from sqlalchemy import select

stmt = select(user_table).order_by(user_table.c.name.desc())

print(stmt)
```

```sql
SELECT user.id, user.name, user.fullname
FROM user ORDER BY user.name DESC
```

A cláusula GROUP BY é usada para agrupar as linhas de uma consulta. As linhas são agrupadas de acordo com os valores de uma ou mais colunas. As funções de agregação podem ser aplicadas a cada grupo.

O SQLAlchemy permite funções SQL de maneira aberta usando um espaço de nomes conhecido como `func`. Este é um objeto construtor especial que criará novas instâncias de `Function` quando fornecido o nome de uma determinada função SQL, que pode ter qualquer nome, bem como zero ou mais argumentos para passar para a função, que são, como em todos os outros casos, construções de Expressões SQL. Por exemplo, para executar a função SQL COUNT() na coluna `user_account.id`, invocamos o nome `count()`.

```python
from sqlalchemy import func

count_fn = func.count(user_table.c.id)

print(count_fn)
```

```python
count(user_account.id)
```

A cláusula HAVING é usada para filtrar os grupos resultantes da cláusula GROUP BY. A cláusula HAVING especifica uma condição que deve ser satisfeita para que um grupo seja incluído nos resultados da consulta.

O SQLAlchemy permite os métodos `Select.group_by()` e `Select.having()`. Abaixo, ilustramos a seleção de campos de nome de usuário, bem como a contagem de endereços, para aqueles usuários que têm mais de um endereço:

```python
with engine.connect() as conn:
    result = conn.execute(
        select(User.name, func.count(Address.id).label("count"))
        .join(Address)
        .group_by(User.name)
        .having(func.count(Address.id) > 1)
    )
    print(result.all())
```

```python
[('sandy', 2)]
```

```sql
SELECT user.name, count(address.id) AS count
FROM user JOIN address ON user.id = address.user_id
GROUP BY user.name
HAVING count(address.id) > :count_1
```

### Ordenar ou Agrupar por um Rótulo

Uma técnica importante, particularmente em alguns bancos de dados, é a capacidade de ORDENAR POR ou AGRUPAR POR uma expressão que já foi declarada na cláusula de colunas, sem declarar novamente a expressão na cláusula ORDER BY ou GROUP BY e, em vez disso, usando o nome da coluna ou o nome rotulado da cláusula de COLUNAS. Essa forma está disponível passando o texto da string com o nome para o método `Select.order_by()` ou `Select.group_by()`. O texto passado não é renderizado diretamente; em vez disso, o nome dado a uma expressão na cláusula de colunas é renderizado como esse nome de expressão no contexto, gerando um erro se nenhuma correspondência for encontrada. Os modificadores unários `asc()` e `desc()` também podem ser usados nessa forma.

```python
from sqlalchemy import func, desc
stmt = (
    select(Address.user_id, func.count(Address.id).label("num_addresses"))
    .group_by("user_id")
    .order_by("user_id", desc("num_addresses"))
)
print(stmt)
```

```sql
SELECT address.user_id, count(address.id) AS num_addresses
FROM address GROUP BY address.user_id ORDER BY address.user_id, num_addresses DESC
```

### Usando aliases

Agora que estamos selecionando de várias tabelas e usando junções, rapidamente nos deparamos com o caso em que precisamos nos referir à mesma tabela várias vezes na cláusula FROM de uma instrução. Conseguimos fazer isso usando **aliases** SQL, que são uma sintaxe que fornece um nome alternativo para uma tabela ou subconsulta pela qual ela pode ser referenciada na instrução.

Na Linguagem de Expressão do SQLAlchemy, esses "nomes" são representados por objetos `FromClause` conhecidos como a construção `Alias`, que é construída no Core usando o método `FromClause.alias()`. Uma construção `Alias` é semelhante a uma construção `Table`, pois também possui um espaço de nomes de objetos `Column` na coleção `Alias.c`. A instrução SELECT abaixo, por exemplo, retorna todos os pares únicos de nomes de usuário:

```python
user_alias_1 = user_table.alias()
user_alias_2 = user_table.alias()
print(
    select(user_alias_1.c.name, user_alias_2.c.name).join_from(
        user_alias_1, user_alias_2, user_alias_1.c.id > user_alias_2.c.id
    )
)
```

```sql
SELECT user_account_1.name, user_account_2.name AS name_1
FROM user_account AS user_account_1
JOIN user_account AS user_account_2 ON user_account_1.id > user_account_2.id
```

#### Aliases de entidade ORM

O equivalente ORM do método `FromClause.alias()` é a função `aliased()` do ORM, que pode ser aplicada a uma entidade como User e Address. Isso produz internamente um objeto `Alias` em relação ao objeto de Tabela original mapeado, mantendo a funcionalidade ORM. 

```python
from sqlalchemy.orm import aliased
address_alias_1 = aliased(Address)
address_alias_2 = aliased(Address)
print(
    select(User)
    .join_from(User, address_alias_1)
    .where(address_alias_1.email_address == "patrick@aol.com")
    .join_from(User, address_alias_2)
    .where(address_alias_2.email_address == "patrick@gmail.com")
)
```

```sql
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
JOIN address AS address_1 ON user_account.id = address_1.user_id
JOIN address AS address_2 ON user_account.id = address_2.user_id
WHERE address_1.email_address = :email_address_1
AND address_2.email_address = :email_address_2
```

### Subconsultas e CTEs (Expressões de Tabela Comuns)

Uma subconsulta em SQL é uma instrução SELECT que é colocada entre parênteses e inserida no contexto de uma instrução de envolvimento, geralmente uma instrução SELECT, mas nem sempre.

Esta seção abordará uma subconsulta chamada "não escalar", que normalmente é colocada na cláusula FROM de uma instrução SELECT de envolvimento. Também abordaremos a Expressão de Tabela Comum, ou CTE, que é usada de maneira semelhante a uma subconsulta, mas inclui recursos adicionais.

O SQLAlchemy usa o objeto `Subquery` para representar uma subconsulta e o CTE para representar uma CTE, geralmente obtidos pelos métodos `Select.subquery()` e `Select.cte()`, respectivamente. Ambos os objetos podem ser usados como um elemento FROM dentro de uma construção `select()` maior.

Podemos construir uma `Subquery` que selecionará uma contagem agregada de linhas da tabela de endereços:

```python
subq = (
    select(func.count(address_table.c.id).label("count"), address_table.c.user_id)
    .group_by(address_table.c.user_id)
    .subquery()
)
print(subq)
```

```sql
SELECT count(address.id) AS count, address.user_id
FROM address GROUP BY address.user_id
```

O objeto `Subquery` se comporta como qualquer outro objeto FROM, como uma `Table`, notavelmente porque inclui um namespace `Subquery.c` das colunas que ele seleciona. Podemos usar esse namespace para nos referirmos tanto à coluna `user_id` quanto à nossa expressão de contagem rotulada personalizada:

```python
print(select(subq.c.user_id, subq.c.count))
```

```sql
SELECT 
    anon_1.user_id,
    anon_1.count
FROM 
    (
        SELECT 
            count(address.id) AS count,
            address.user_id AS user_id
        FROM 
            address 
        GROUP BY 
            address.user_id
    ) AS anon_1
```

Podemos utilizar o `join_from()` para juntar a subconsulta com a tabela de usuários:

```python
stmt = select(user_table.c.name, user_table.c.fullname, subq.c.count).join_from(
    user_table, subq
)

print(stmt)
```

```sql
SELECT 
    user_account.name, 
    user_account.fullname, 
    anon_1.count
FROM 
    user_account 
JOIN 
    (
        SELECT 
            count(address.id) AS count, 
            address.user_id AS user_id
        FROM 
            address 
        GROUP BY 
            address.user_id
        ) AS anon_1 
ON 
    user_account.id = anon_1.user_id
```

Para realizar a junção entre user_account e address, utilizamos o método `Select.join_from()`. Como já foi ilustrado anteriormente, a cláusula ON dessa junção foi inferida novamente com base nas restrições de chave estrangeira. Mesmo que uma subconsulta SQL em si não tenha nenhuma restrição, o SQLAlchemy pode atuar com base nas restrições representadas nas colunas, determinando que a coluna `subq.c.user_id` é derivada da coluna `address_table.c.user_id`, que expressa um relacionamento de chave estrangeira de volta para a coluna `user_table.c.id`, que é então usada para gerar a cláusula ON.

### Expressões de tabela comuns (CTEs)

O uso da construção `CTE` no SQLAlchemy é praticamente o mesmo que o uso da construção `Subquery`. Ao alterar a invocação do método `Select.subquery()` para usar `Select.cte()` em vez disso, podemos usar o objeto resultante como um elemento FROM da mesma maneira, mas o SQL gerado é a sintaxe de expressão de tabela comum, que é bastante diferente:

```python
subq = (
    select(func.count(address_table.c.id).label("count"), address_table.c.user_id)
    .group_by(address_table.c.user_id)
    .cte()
)

stmt = select(user_table.c.name, user_table.c.fullname, subq.c.count).join_from(
    user_table, subq
)

print(stmt)
```

```sql
WITH 
    anon_1 AS (
        SELECT 
            count(address.id) AS count,
            address.user_id AS user_id
        FROM 
            address 
        GROUP BY 
            address.user_id
        )
 SELECT 
    user_account.name,
    user_account.fullname,
    anon_1.count
FROM 
    user_account 
JOIN 
    anon_1 
ON 
    user_account.id = anon_1.user_id
```

#### Subconsultas/CTEs de Entidades ORM

No ORM, a construção `aliased()` pode ser usada para associar uma entidade ORM, como nossa classe `User` ou `Address`, a qualquer conceito `FromClause` que represente uma fonte de linhas. A seção anterior, "Aliases de Entidades ORM", ilustra o uso de `aliased()` para associar a classe mapeada a um `Alias` de sua `Table` mapeada. Aqui ilustramos o uso do `aliased()` fazendo a mesma associação tanto a uma `Subquery` quanto a uma `CTE` gerada a partir de uma construção `Select`, que em última instância deriva da mesma `Table` mapeada.

Abaixo, temos um exemplo de aplicação do `aliased()` à construção `Subquery`, para que as entidades ORM possam ser extraídas de suas linhas. O resultado mostra uma série de objetos `User` e `Address`, onde os dados para cada objeto `Address` vieram de uma subconsulta contra a tabela `address` e não diretamente daquela tabela:

O ORM também suporta subconsultas e CTEs, embora a sintaxe seja um pouco diferente. Para criar uma subconsulta ORM, usamos o método `Query.subquery()`:

```python
subq = select(Address).where(~Address.email_address.like("%@aol.com")).subquery()
address_subq = aliased(Address, subq)
stmt = (
    select(User, address_subq)
    .join_from(User, address_subq)
    .order_by(User.id, address_subq.id)
)
with Session(engine) as session:
    for user, address in session.execute(stmt):
        print(f"{user} {address}")
```

```python
User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
```

```sql
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname,
    anon_1.id AS id_1,
    anon_1.email_address,
    anon_1.user_id
FROM 
    user_account JOIN (
        SELECT 
            address.id AS id,
            address.email_address AS email_address,
            address.user_id AS user_id
        FROM 
            address
        WHERE 
            address.email_address NOT LIKE '%@aol.com'
        ) AS anon_1 
ON 
    user_account.id = anon_1.user_id
ORDER BY 
    user_account.id,
    anon_1.id
```

Outro exemplo utilizando CTEs:

```python
cte_obj = select(Address).where(~Address.email_address.like("%@aol.com")).cte()
address_cte = aliased(Address, cte_obj)
stmt = (
    select(User, address_cte)
    .join_from(User, address_cte)
    .order_by(User.id, address_cte.id)
)
with Session(engine) as session:
    for user, address in session.execute(stmt):
        print(f"{user} {address}")
```

```python
User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
```

```sql
WITH 
    anon_1 AS (
        SELECT 
            address.id AS id,
            address.email_address AS email_address,
            address.user_id AS user_id
        FROM 
            address
        WHERE 
            address.email_address NOT LIKE ?
        )
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname,
    anon_1.id AS id_1,
    anon_1.email_address,
    anon_1.user_id
FROM 
    user_account
JOIN 
    anon_1
ON 
    user_account.id = anon_1.user_id
ORDER BY 
    user_account.id,
    anon_1.id
```

### Subconsultas Escalares e Correlacionadas

Uma subconsulta é uma consulta SQL que é usada dentro de outra consulta. Subconsultas podem ser usadas para uma variedade de propósitos, incluindo:

* Selecionar dados de uma tabela baseada nos resultados de outra consulta
* Filtrar linhas com base nos resultados de outra consulta
* Agrupar linhas com base nos resultados de outra consulta

Existem dois tipos principais de subconsultas: subconsultas escalares e subconsultas correlacionadas.

**Subconsultas Escalares**

Uma subconsulta escalar é uma subconsulta que retorna um único valor. Subconsultas escalares podem ser usadas na cláusula SELECT, na cláusula WHERE, na cláusula GROUP BY e na cláusula HAVING.

Por exemplo, a seguinte consulta usa uma subconsulta escalar na cláusula SELECT para selecionar o nome do funcionário que tem o maior salário:

```sql
SELECT name
FROM employees
WHERE salary = (
    SELECT MAX(salary)
    FROM employees
);
```

Nesta consulta, a subconsulta escalar retorna o valor máximo da coluna `salary` da tabela `employees`. A consulta externa usa este valor para selecionar o funcionário com o salário mais alto.

**Subconsultas Correlacionadas**

Uma subconsulta correlacionada é uma subconsulta que faz referência a uma variável ou expressão de uma consulta externa. Subconsultas correlacionadas podem ser usadas para uma variedade de propósitos, incluindo:

* Filtrar linhas com base nos resultados de uma consulta externa
* Agrupar linhas com base nos resultados de uma consulta externa

Por exemplo, a seguinte consulta usa uma subconsulta correlacionada na cláusula WHERE para selecionar todos os clientes que moram no mesmo estado que seu representante de vendas:

```sql
SELECT *
FROM customers
WHERE state = (
    SELECT state
    FROM representatives
    WHERE representatives.id = customers.representative_id
);
```

Nesta consulta, a subconsulta correlacionada retorna o estado do representante de vendas de cada cliente. A consulta externa usa este valor para selecionar os clientes que moram no mesmo estado que seu representante de vendas.

A principal diferença entre subconsultas escalares e correlacionadas é que subconsultas escalares são avaliadas uma vez, enquanto subconsultas correlacionadas são avaliadas uma vez para cada linha na consulta externa.

O SQLAlchemy representa a subconsulta escalar usando a construção ScalarSelect, que faz parte da hierarquia de expressões `ColumnElement`, em contraste com a subconsulta regular, que é representada pela construção `Subquery`, presente na hierarquia de `FromClause`.

As subconsultas escalares são frequentemente, mas nem sempre, usadas com funções de agregação. Uma subconsulta escalar é indicada explicitamente pelo uso do método `Select.scalar_subquery()` como abaixo. Sua forma de string padrão, quando convertida em string por si só, é renderizada como uma instrução SELECT comum que está selecionando de duas tabelas:

```python
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .scalar_subquery()
)
print(subq)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
)
```

O objeto `subq` acima agora faz parte da hierarquia de expressões SQL `ColumnElement`, de forma que ele pode ser usado como qualquer outra expressão de coluna:

```python
print(subq == 5)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
) = :param_1
```

```python
print(subq > 5)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
) > :param_1
```

```python
print(subq + 5)
```

```sql
(
    SELECT
    count(address.id) AS count_1
    FROM 
        address,
        user_account
    WHERE 
        user_account.id = address.user_id
) + :param_1
```

Embora a subconsulta escalar, por si só, renderize tanto `user_account` quanto `address` em sua cláusula FROM quando convertida em string, ao incorporá-la em uma construção `select()` de envolvimento que lida com a tabela `user_account`, a tabela `user_account` é automaticamente correlacionada, o que significa que ela não é renderizada na cláusula FROM da subconsulta:

```python
stmt = select(user_table.c.name, subq.label("address_count"))
print(stmt)
```

```sql
SELECT 
    user_account.name,
    (
        SELECT
        count(address.id) AS count_1
        FROM 
            address
        WHERE 
            user_account.id = address.user_id
    ) AS address_count
FROM
    user_account
```

Subconsultas correlacionadas simples geralmente farão o que é desejado. No entanto, no caso em que a correlação for ambígua, o SQLAlchemy nos informará que é necessária mais clareza:

```python
stmt = (
    select(
        user_table.c.name,
        address_table.c.email_address,
        subq.label("address_count"),
    )
    .join_from(user_table, address_table)
    .order_by(user_table.c.id, address_table.c.id)
)
print(stmt)
```

```bash
Traceback (most recent call last):

InvalidRequestError: Select statement '<... Select object at ...>' returned
no FROM clauses due to auto-correlation; specify correlate(<tables>) to
control correlation manually.
```

Para especificar que a tabela `user_table` é a que desejamos correlacionar, fazemos isso usando os métodos `ScalarSelect.correlate()` ou `ScalarSelect.correlate_except()`:

```python
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .scalar_subquery()
    .correlate(user_table)
)

stmt = (
    select(
        user_table.c.name,
        address_table.c.email_address,
        subq.label("address_count"),
    )
    .join_from(user_table, address_table)
    .order_by(user_table.c.id, address_table.c.id)
)

print(stmt)
```

```sql
SELECT 
    user_account.name,
    address.email_address,
    (
        SELECT
        count(address.id) AS count_1
        FROM 
            address
        WHERE 
            user_account.id = address.user_id
    ) AS address_count
FROM
    user_account 
JOIN 
    address
ON 
    user_account.id = address.user_id
ORDER BY
    user_account.id,
    address.id
```

```python
[
    ('spongebob', 'spongebob@sqlalchemy.org', 1),
    ('sandy', 'sandy@sqlalchemy.org', 2),
    ('sandy', 'sandy@squirrelpower.org', 2)
]
```

### Correlação LATERAL

A correlação LATERAL é uma forma de correlação que permite que você consulte dados de uma tabela relacionada sem usar uma subconsulta correlacionada. A correlação LATERAL é mais eficiente do que as subconsultas correlacionadas, pois não precisa avaliar a subconsulta para cada linha na consulta externa.

A correlação LATERAL é declarada usando a cláusula LATERAL. A cláusula LATERAL é seguida por uma subconsulta que retorna uma tabela. A consulta externa pode então consultar a tabela retornada pela subconsulta LATERAL.

Por exemplo, a seguinte consulta usa a correlação LATERAL para selecionar todos os clientes e seus representantes de vendas:

```sql
SELECT c.name, r.name
FROM customers c
LATERAL (
    SELECT name
    FROM representatives
    WHERE representatives.id = c.representative_id
);
```

Nesta consulta, a subconsulta LATERAL retorna uma tabela com uma coluna chamada `name`. A consulta externa consulta esta tabela para obter o nome do representante de vendas de cada cliente.

A correlação LATERAL é uma ferramenta poderosa que pode ser usada para simplificar consultas SQL.

Não, a consulta lateral não é suportada por todos os bancos de dados SQL. Os bancos de dados SQL mais populares que suportam a consulta lateral incluem:

* MySQL
* PostgreSQL
* Oracle
* SQL Server

Alguns bancos de dados SQL mais antigos, como o SQL Server 2000, não suportam a consulta lateral.

A consulta lateral é uma funcionalidade relativamente recente no SQL. Foi introduzida pela primeira vez no SQL:2011. A consulta lateral é uma funcionalidade opcional no SQL:2011, o que significa que os bancos de dados SQL não são obrigados a suportá-la. A consulta lateral foi tornada obrigatória no SQL:2016.

O SQLAlchemy representa a correlação LATERAL usando a construção `Lateral`, que faz parte da hierarquia de expressões `FromClause`. A construção `Lateral` é usada como um elemento FROM em uma instrução `select()` de envolvimento, onde a subconsulta é passada para o método `Lateral.select()`:

```python
subq = (
    select(
        func.count(address_table.c.id).label("address_count"),
        address_table.c.email_address,
        address_table.c.user_id,
    )
    .where(user_table.c.id == address_table.c.user_id)
    .lateral()
)
stmt = (
    select(user_table.c.name, subq.c.address_count, subq.c.email_address)
    .join_from(user_table, subq)
    .order_by(user_table.c.id, subq.c.email_address)
)
print(stmt)
```

```sql
SELECT 
    user_account.name,
    anon_1.address_count,
    anon_1.email_address
FROM
    user_account
JOIN LATERAL (
    SELECT 
        count(address.id) AS address_count,
        address.email_address AS email_address,
        address.user_id AS user_id
    FROM 
        address
    WHERE 
        user_account.id = address.user_id
) AS anon_1
ON 
    user_account.id = anon_1.user_id
ORDER BY
    user_account.id,
    anon_1.email_address
```

### UNION, UNION ALL e outras operações de conjunto

As cláusulas UNION e UNION ALL são usadas para combinar os resultados de duas ou mais consultas SQL. A cláusula UNION retorna apenas linhas únicas nos resultados, enquanto a cláusula UNION ALL retorna todas as linhas, incluindo as duplicatas.

A cláusula UNION é declarada usando o operador UNION. As consultas SQL que serão combinadas são separadas por vírgulas.

Por exemplo, a seguinte consulta usa a cláusula UNION para combinar os resultados de duas consultas:

```sql
SELECT name, email
FROM customers
UNION
SELECT name, email
FROM leads;
```

Esta consulta retornará uma tabela com todas as linhas das tabelas `customers` e `leads`. As linhas duplicadas serão removidas.

A cláusula UNION ALL é declarada usando o operador UNION ALL. As consultas SQL que serão combinadas são separadas por vírgulas.

Por exemplo, a seguinte consulta usa a cláusula UNION ALL para combinar os resultados de duas consultas:

```sql
SELECT name, email
FROM customers
UNION ALL
SELECT name, email
FROM leads;
```

Esta consulta retornará uma tabela com todas as linhas das tabelas `customers` e `leads`, incluindo as duplicatas.

Aqui está uma tabela que resume as diferenças entre as cláusulas UNION e UNION ALL:

| Cláusula | Retorna linhas duplicadas |
|---|---|
| UNION | Não |
| UNION ALL | Sim |

Em SQL, as instruções SELECT podem ser mescladas usando a operação SQL UNION ou UNION ALL, que produz o conjunto de todas as linhas produzidas por uma ou mais instruções juntas. Outras operações de conjunto, como INTERSECT [ALL] e EXCEPT [ALL], também são possíveis.

O construtor `Select` do SQLAlchemy suporta composições desse tipo usando funções como `union()`, `intersect()` e `except_()`, e seus equivalentes "all" `union_all()`, `intersect_all()` e `except_all()`. Todas essas funções aceitam um número arbitrário de sub-selecionáveis, que geralmente são construtores `Select`, mas também podem ser uma composição existente.

O construtor produzido por essas funções é o `CompoundSelect`, que é usado da mesma forma que o construtor `Select`, exceto que possui menos métodos. O `CompoundSelect` produzido pelo `union_all()`, por exemplo, pode ser invocado diretamente usando `Connection.execute()`:

```python
from sqlalchemy import union_all
stmt1 = select(user_table).where(user_table.c.name == "sandy")
stmt2 = select(user_table).where(user_table.c.name == "spongebob")
u = union_all(stmt1, stmt2)
with engine.connect() as conn:
    result = conn.execute(u)
    print(result.all())
```

```python
[
    (2, 'sandy', 'Sandy Cheeks'),
    (1, 'spongebob', 'Spongebob Squarepants')
]
```

```sql
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname
FROM
    user_account
WHERE 
    user_account.name = :name_1
UNION ALL
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname
FROM
    user_account
WHERE 
    user_account.name = :name_2
```

#### Selecionando Entidades ORM a partir de Uniões

Os exemplos anteriores ilustraram como construir uma UNION usando dois objetos de `Table` para retornar linhas do banco de dados. Se quisermos usar uma UNION ou outra operação de conjunto para selecionar linhas que depois recebemos como objetos ORM, existem duas abordagens que podem ser usadas. Em ambos os casos, primeiro construímos um objeto `select()` ou `CompoundSelect` que representa a instrução SELECT / UNION / etc que desejamos executar; essa instrução deve ser composta em relação às entidades ORM de destino ou aos objetos de `Table` mapeados subjacentes a elas:

```python
stmt1 = select(User).where(User.name == "sandy")
stmt2 = select(User).where(User.name == "spongebob")
u = union_all(stmt1, stmt2)
```

Para um SELECT simples com UNION que ainda não está aninhado dentro de uma subconsulta, isso frequentemente pode ser usado em um contexto de busca de objetos ORM usando o método `Select.from_statement()`. Com essa abordagem, a declaração UNION representa a consulta inteira; nenhum critério adicional pode ser adicionado após o uso de `Select.from_statement()`:

```python
orm_stmt = select(User).from_statement(u)
with Session(engine) as session:
    for obj in session.execute(orm_stmt).scalars():
        print(obj)
```

```python
User(id=2, name='sandy', fullname='Sandy Cheeks')
User(id=1, name='spongebob', fullname='Spongebob Squarepants')
```

```sql
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname
FROM
    user_account
WHERE 
    user_account.name = :name_1
UNION ALL
SELECT 
    user_account.id,
    user_account.name,
    user_account.fullname
FROM
    user_account
WHERE 
    user_account.name = :name_2
```

Para usar uma UNION ou outro construto relacionado a conjuntos como um componente relacionado a entidades de maneira mais flexível, o construtor `CompoundSelect` pode ser organizado em uma subconsulta usando `CompoundSelect.subquery()`, que depois se conecta a objetos ORM usando a função `aliased()`. Isso funciona da mesma maneira introduzida em Subconsultas/CTEs de Entidades ORM, para primeiro criar um "mapeamento" ad hoc da nossa entidade desejada para a subconsulta e, em seguida, selecionar dessa nova entidade como se fosse qualquer outra classe mapeada. No exemplo abaixo, podemos adicionar critérios adicionais, como ORDER BY, fora da própria UNION, pois podemos filtrar ou ordenar pelas colunas exportadas pela subconsulta:

```python
user_alias = aliased(User, u.subquery())
orm_stmt = select(user_alias).order_by(user_alias.id)
with Session(engine) as session:
    for obj in session.execute(orm_stmt).scalars():
        print(obj)
```

```python
User(id=1, name='spongebob', fullname='Spongebob Squarepants')
User(id=2, name='sandy', fullname='Sandy Cheeks')
```

```sql
SELECT 
    anon_1.id,
    anon_1.name,
    anon_1.fullname
FROM 
    (
        SELECT 
            user_account.id AS id,
            user_account.name AS name,
            user_account.fullname AS fullname
        FROM 
            user_account
        WHERE 
            user_account.name = :name_1
        UNION ALL
        SELECT 
            user_account.id AS id,
            user_account.name AS name,
            user_account.fullname AS fullname
        FROM 
            user_account
        WHERE 
            user_account.name = :name_2
    ) AS anon_1
ORDER BY
    anon_1.id
```

### Subconsultas EXISTS

A palavra-chave SQL EXISTS é um operador que é usado com subconsultas escalares para retornar um booleano verdadeiro ou falso, dependendo se a instrução SELECT retornaria uma linha. O SQLAlchemy inclui uma variante do objeto `ScalarSelect` chamado `Exists`, que gerará uma subconsulta EXISTS e é mais convenientemente gerada usando o método `SelectBase.exists()`. Abaixo, produzimos um EXISTS para que possamos retornar linhas de `user_account` que tenham mais de uma linha relacionada em `address`:

```python
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .group_by(address_table.c.user_id)
    .having(func.count(address_table.c.id) > 1)
).exists()
with engine.connect() as conn:
    result = conn.execute(select(user_table.c.name).where(subq))
    print(result.all())
```

```python
[('sandy',)]
```

```sql
SELECT 
    user_account.name
FROM
    user_account
WHERE 
    EXISTS (
        SELECT 
            count(address.id) AS count_1
        FROM 
            address
        WHERE 
            user_account.id = address.user_id
        GROUP BY 
            address.user_id
        HAVING 
            count(address.id) > :count_2
    )
```

O construto EXISTS é mais frequentemente usado como uma negação, por exemplo, NOT EXISTS, pois fornece uma forma eficiente em SQL de localizar linhas para as quais uma tabela relacionada não possui linhas. Abaixo, selecionamos nomes de usuários que não têm endereços de e-mail; observe o operador de negação binária (~) usado dentro da segunda cláusula WHERE:

```python
subq = (
    select(address_table.c.id).where(user_table.c.id == address_table.c.user_id)
).exists()
with engine.connect() as conn:
    result = conn.execute(select(user_table.c.name).where(~subq))
    print(result.all())
```

```python
[('patrick',)]
```

```sql
SELECT 
    user_account.name
FROM
    user_account
WHERE 
    NOT EXISTS (
        SELECT 
            address.id AS id
        FROM 
            address
        WHERE 
            user_account.id = address.user_id
    )
```

### Trabalhando com funções SQL

O objeto `func` atua como uma fábrica para criar novos objetos `Function`, que quando usados em uma construção como `select()`, produzem uma exibição de função SQL, geralmente consistindo de um nome, alguns parênteses (embora nem sempre) e possivelmente alguns argumentos. Exemplos de funções SQL típicas incluem:

- A função `count()`, uma função de agregação que conta quantas linhas são retornadas:

```python
print(select(func.count()).select_from(user_table))
```

```sql
SELECT 
    count(*) AS count_1
FROM
    user_account
```

- A função `lower()`, uma função de string que converte uma string para minúsculas:

```python
print(select(func.lower("A String With Much UPPERCASE")))
```

```sql
SELECT 
    lower(:lower_1) AS lower_2
```

- A função `now()`, que fornece a data e hora atuais; como esta é uma função comum, o SQLAlchemy sabe como renderizá-la de forma diferente para cada backend, no caso do SQLite, usando a função CURRENT_TIMESTAMP:

```python
stmt = select(func.now())
with engine.connect() as conn:
    result = conn.execute(stmt)
    print(result.all())
```

```python
[('2021-08-22 16:25:00',)]
```

```sql
SELECT 
    CURRENT_TIMESTAMP AS now_1
```

Como a maioria dos backends de banco de dados apresenta dezenas, se não centenas, de funções SQL diferentes, o `func` tenta ser o mais liberal possível no que aceita. Qualquer nome acessado deste espaço de nomes é automaticamente considerado uma função SQL que será renderizada de maneira genérica:

```python
print(select(func.some_crazy_function(user_table.c.name, 17)))
```

```sql
SELECT 
    some_crazy_function(user_account.name, :some_crazy_function_1) AS some_crazy_function_2
FROM
    user_account
```

Ao mesmo tempo, um conjunto relativamente pequeno de funções SQL extremamente comuns, como `count`, `now`, `max`, `concat`, inclui versões pré-empacotadas delas mesmas que fornecem informações de tipo adequadas, bem como geração de SQL específico do backend em alguns casos. O exemplo abaixo contrasta a geração de SQL que ocorre para o dialeto PostgreSQL em comparação com o dialeto Oracle para a função `now`:

```python
from sqlalchemy.dialects import postgresql
print(select(func.now()).compile(dialect=postgresql.dialect()))
```

```sql
SELECT 
    CURRENT_TIMESTAMP AS now_1
```

```python
from sqlalchemy.dialects import oracle
print(select(func.now()).compile(dialect=oracle.dialect()))
```

```sql
SELECT 
    CURRENT_TIMESTAMP FROM DUAL
```

#### Funções possuem tipos de retornos

Como as funções são expressões de colunas, elas também têm tipos de dados SQL que descrevem o tipo de dado de uma expressão SQL gerada. Nos referimos a esses tipos como "tipos de retorno SQL" aqui, em referência ao tipo de valor SQL que é retornado pela função no contexto de uma expressão SQL do lado do banco de dados, em oposição ao "tipo de retorno" de uma função Python.

O tipo de retorno SQL de qualquer função SQL pode ser acessado, geralmente para fins de depuração, referindo-se ao atributo Function.type:

```python
print(func.now().type)
```

```python
DateTime()
```

Esses tipos de retorno SQL são significativos ao usar a expressão da função no contexto de uma expressão maior; ou seja, os operadores matemáticos funcionarão melhor quando o tipo de dados da expressão for algo como Integer ou Numeric, acessadores JSON precisam ser usados com um tipo como JSON para funcionar adequadamente. Certas classes de funções retornam linhas inteiras em vez de valores de colunas, quando há necessidade de se referir a colunas específicas; tais funções são chamadas de funções de valor de tabela.

O tipo de retorno SQL da função também pode ser significativo ao executar uma instrução e obter linhas de volta, nos casos em que o SQLAlchemy precisa aplicar o processamento do conjunto de resultados. Um exemplo disso são as funções relacionadas a datas no SQLite, onde os tipos de dados DateTime e relacionados do SQLAlchemy desempenham o papel de converter valores de string em objetos datetime() do Python à medida que as linhas de resultado são recebidas.

Para aplicar um tipo específico a uma função que estamos criando, passamos esse tipo usando o parâmetro Function.type_; o argumento de tipo pode ser uma classe TypeEngine ou uma instância. No exemplo abaixo, passamos a classe JSON para gerar a função json_object() do PostgreSQL, observando que o tipo de retorno SQL será do tipo JSON:

```python
from sqlalchemy import JSON
function_expr = func.json_object('{a, 1, b, "def", c, 3.5}', type_=JSON)
print(select(function_expr))
```

```sql
SELECT 
    json_object(:json_object_1) AS json_object_2
```

Ao criar nossa função JSON com o tipo de dados JSON, o objeto de expressão SQL adquire recursos relacionados ao JSON, como o acesso a elementos:

```python
stmt = select(function_expr["def"])
print(stmt)
```

```sql
SELECT 
    json_object(:json_object_1)[:json_object_2] AS anon_1
```

#### Funções Incorporadas Têm Tipos de Retorno Pré-Configurados

Para funções agregadas comuns como `count`, `max`, `min`, bem como um número muito pequeno de funções de data como `now` e funções de string como `concat`, o tipo de retorno SQL é configurado adequadamente, às vezes com base no uso. A função `max` e funções de filtragem agregada semelhantes configurarão o tipo de retorno SQL com base no argumento fornecido:

```python
m1 = func.max(Column("some_int", Integer))
m1.type

m2 = func.max(Column("some_str", String))
m2.type
```

```python
Integer()
String()
```

Funções de data e hora geralmente correspondem a expressões SQL descritas por `DateTime`, `Date` ou `Time`:

```python	
func.now().type
func.current_date().type
func.current_time().type
```

```python
DateTime()
Date()
Time()
```

Uma função de string conhecida, como `concat`, sabe que uma expressão SQL será do tipo `String`:

```python
func.concat("some string", "some other string").type
```

```python
String()
```

No entanto, para a grande maioria das funções SQL, o SQLAlchemy não as possui explicitamente presentes em sua lista muito pequena de funções conhecidas. Por exemplo, embora geralmente não haja problemas em usar as funções SQL `func.lower()` e `func.upper()` para converter a caixa de strings, o SQLAlchemy na verdade não conhece essas funções, então elas têm um tipo de retorno SQL "nulo":

```python
func.upper("lowercase").type
```

```python
NullType()
```

Para funções simples como `upper` e `lower`, o problema geralmente não é significativo, pois os valores de string podem ser recebidos do banco de dados sem nenhum tratamento de tipo especial no lado do SQLAlchemy, e as regras de coerção de tipo do SQLAlchemy muitas vezes podem adivinhar corretamente a intenção também; por exemplo, o operador + do Python será corretamente interpretado como o operador de concatenação de strings com base na análise de ambos os lados da expressão:

```python
print(select(func.upper("lowercase") + " suffix"))
```

```sql
SELECT 
    upper(:upper_1) || :upper_2 AS anon_1
```

No geral, o cenário em que o parâmetro `Function.type_` é provavelmente necessário é:

- A função ainda não é uma função incorporada ao SQLAlchemy; isso pode ser evidenciado criando a função e observando o atributo `Function.type`, ou seja:

```python
func.count().type
```

```python
Integer()
```

vs.:

```python
func.json_object('{"a", "b"}').type
```

```python
NullType()
```

- É necessário suporte para expressões conscientes de função; isso se refere mais frequentemente a operadores especiais relacionados a tipos de dados como JSON ou ARRAY.
- É necessário processamento de valor de resultado, que pode incluir tipos como `DateTime`, `Boolean`, `Enum` ou novamente tipos de dados especiais como JSON, ARRAY.

### Técnicas Avançadas de Funções SQL

As subseções a seguir ilustram mais coisas que podem ser feitas com funções SQL. Embora essas técnicas sejam menos comuns e mais avançadas do que o uso básico de funções SQL, elas ainda são extremamente populares, em grande parte devido ao foco do PostgreSQL em formas de função mais complexas, incluindo formas de tabela e coluna que são populares com dados JSON.

#### Usando Funções de Janela

A função de janela, ou "Window Function," em SQL é uma função analítica que permite realizar cálculos sobre um conjunto de linhas relacionadas a uma linha específica em um resultado de consulta. Essas funções são frequentemente usadas para calcular agregações ou realizar análises dentro de um grupo de linhas, sem a necessidade de criar subconsultas ou junções complexas. Vou explicar como funciona com exemplos.

Suponha que temos uma tabela chamada "vendas" com os seguintes dados:

| data       | produto | quantidade | valor_venda |
|------------|---------|------------|-------------|
| 2023-01-01 | A       | 10         | 100         |
| 2023-01-01 | B       | 5          | 50          |
| 2023-01-02 | A       | 8          | 80          |
| 2023-01-02 | B       | 7          | 70          |
| 2023-01-03 | A       | 12         | 120         |
| 2023-01-03 | B       | 4          | 40          |

Agora, suponha que queremos calcular a soma acumulativa da coluna "valor_venda" por data, usando uma função de janela. Podemos fazer isso usando a função `SUM()` como uma função de janela da seguinte forma:

```sql
SELECT
    data,
    produto,
    quantidade,
    valor_venda,
    SUM(valor_venda) OVER (PARTITION BY data ORDER BY produto) AS soma_acumulativa
FROM
    vendas
ORDER BY
    data, produto;
```

Neste exemplo, a função `SUM(valor_venda) OVER (PARTITION BY data ORDER BY produto)` atua como uma função de janela. Aqui estão os detalhes:

- `SUM(valor_venda)`: Isso é a função de agregação que somará os valores de "valor_venda" para cada linha.
- `OVER (PARTITION BY data ORDER BY produto)`: Isso define a janela da função. Ele instrui o SQL a calcular a soma acumulativa para cada data, e dentro de cada data, ordenar os resultados por produto.

A saída seria:

| data       | produto | quantidade | valor_venda | soma_acumulativa |
|------------|---------|------------|-------------|------------------|
| 2023-01-01 | A       | 10         | 100         | 100              |
| 2023-01-01 | B       | 5          | 50          | 150              |
| 2023-01-02 | A       | 8          | 80          | 80               |
| 2023-01-02 | B       | 7          | 70          | 150              |
| 2023-01-03 | A       | 12         | 120         | 120              |
| 2023-01-03 | B       | 4          | 40          | 160              |

A função de janela `SUM()` calcula a soma acumulativa dos valores de "valor_venda" para cada data, mantendo a ordenação por produto. Isso é apenas um exemplo simples, e funções de janela podem ser usadas para realizar uma variedade de cálculos analíticos mais complexos em conjunto com as cláusulas `PARTITION BY` e `ORDER BY` para definir o escopo e a ordem das operações.

Uma função de janela é um uso especial de uma função de agregação SQL que calcula o valor de agregação sobre as linhas que estão sendo retornadas em um grupo à medida que as linhas de resultado individuais são processadas. Enquanto uma função como `MAX()` lhe dará o valor mais alto de uma coluna dentro de um conjunto de linhas, usando a mesma função como uma "função de janela" lhe dará o valor mais alto para cada linha, naquele momento.

No SQL, funções de janela permitem especificar as linhas sobre as quais a função deve ser aplicada, um valor de "partição" que considera a janela sobre diferentes subconjuntos de linhas e uma expressão "order by" que indica, de forma importante, a ordem em que as linhas devem ser aplicadas à função de agregação.

No SQLAlchemy, todas as funções SQL geradas pelo espaço de nomes `func` incluem um método `FunctionElement.over()` que concede a sintaxe da função de janela, ou "OVER"; a construção produzida é a construção Over.

Uma função comum usada com funções de janela é a função `row_number()` que simplesmente conta as linhas. Podemos particionar essa contagem de linhas em relação ao nome do usuário para numerar os endereços de e-mail de usuários individuais:

```python
stmt = (
    select(
        func.row_number().over(partition_by=user_table.c.name),
        user_table.c.name,
        address_table.c.email_address,
    )
    .select_from(user_table)
    .join(address_table)
)
with engine.connect() as conn:  
    result = conn.execute(stmt)
    print(result.all())
```

```python
[
    (1, 'sandy', 'sandy@sqlalchemy.org'),
    (2, 'sandy', 'sandy@squirrelpower.org'),
    (1, 'spongebob', 'spongebob@sqlalchemy.org')
]
```

```sql
SELECT 
    row_number() OVER (PARTITION BY user_account.name) AS row_number_1,
    user_account.name,
    address.email_address
FROM
    user_account
JOIN
    address
ON
    user_account.id = address.user_id
```

Acima, o parâmetro `FunctionElement.over.partition_by` é usado para que a cláusula PARTITION BY seja incorporada dentro da cláusula OVER. Também podemos fazer uso da cláusula ORDER BY usando `FunctionElement.over.order_by`:

```python
stmt = (
    select(
        func.count().over(order_by=user_table.c.name),
        user_table.c.name,
        address_table.c.email_address,
    )
    .select_from(user_table)
    .join(address_table)
)
with engine.connect() as conn:  
    result = conn.execute(stmt)
    print(result.all())
```

```python
[
    (2, 'sandy', 'sandy@sqlalchemy.org'),
    (2, 'sandy', 'sandy@squirrelpower.org'),
    (3, 'spongebob', 'spongebob@sqlalchemy.org')
]
```

```sql
SELECT 
    count(*) OVER (ORDER BY user_account.name) AS count_1,
    user_account.name,
    address.email_address
FROM
    user_account
JOIN
    address
ON
    user_account.id = address.user_id
```

### Modificadores Especiais WITHIN GROUP, FILTER

A sintaxe SQL "WITHIN GROUP" é usada em conjunto com uma função de agregação de "conjunto ordenado" ou "conjunto hipotético". Funções comuns de "conjunto ordenado" incluem `percentile_cont()` e `rank()`. O SQLAlchemy inclui implementações incorporadas como `rank`, `dense_rank`, `mode`, `percentile_cont` e `percentile_disc`, que incluem um método `FunctionElement.within_group()`:

```python
print(
    func.unnest(
        func.percentile_disc([0.25, 0.5, 0.75, 1]).within_group(user_table.c.name)
    )
)
```

```sql
unnest(percentile_disc(:percentile_disc_1) WITHIN GROUP (ORDER BY user_account.name))
```

"FILTER" é suportado por alguns sistemas de banco de dados para limitar o alcance de uma função de agregação a um subconjunto específico de linhas em comparação com o conjunto total de linhas retornadas, e isso está disponível por meio do método `FunctionElement.filter()`:

```python
stmt = (
    select(
        func.count(address_table.c.email_address).filter(user_table.c.name == "sandy"),
        func.count(address_table.c.email_address).filter(
            user_table.c.name == "spongebob"
        ),
    )
    .select_from(user_table)
    .join(address_table)
)
with engine.connect() as conn:  
    result = conn.execute(stmt)
    print(result.all())
```

```python
[(2, 1)]
```

```sql
SELECT 
    count(address.email_address) FILTER (WHERE user_account.name = :name_1) AS count_1,
    count(address.email_address) FILTER (WHERE user_account.name = :name_2) AS count_2
FROM
    user_account
JOIN
    address
ON
    user_account.id = address.user_id
```

### Funções com Valor de Tabela

Funções com Valor de Tabela (Table-Valued Functions) em SQL são funções que retornam uma tabela como resultado. Essas funções são frequentemente usadas para gerar conjuntos de dados ou realizar consultas complexas que retornam múltiplas linhas e colunas. Vou explicar com um exemplo prático.

Suponha que temos uma tabela chamada "produtos" com os seguintes dados:

| id  | nome      | preço |
|----|-----------|-------|
| 1  | Produto A | 10.00 |
| 2  | Produto B | 15.00 |
| 3  | Produto C | 20.00 |

Agora, suponha que queremos criar uma função com valor de tabela que retorna todos os produtos com preços acima de um determinado valor. Aqui está como você pode fazer isso em SQL:

```sql
-- Definindo a função com valor de tabela
CREATE FUNCTION ProdutosAcimaDoPreco(p_preco decimal) 
RETURNS TABLE (id int, nome varchar(255), preço decimal) AS $$
BEGIN
    RETURN QUERY
    SELECT id, nome, preço
    FROM produtos
    WHERE preço > p_preco;
END;
$$ LANGUAGE plpgsql;
```

Neste exemplo:

- `CREATE FUNCTION ProdutosAcimaDoPreco(p_preco decimal)`: Estamos criando uma função chamada "ProdutosAcimaDoPreco" que aceita um parâmetro "p_preco" do tipo decimal.

- `RETURNS TABLE (id int, nome varchar(255), preço decimal)`: Indicamos que a função retornará uma tabela com três colunas: "id," "nome," e "preço."

- `BEGIN`: Início do bloco de código da função.

- `RETURN QUERY`: Esta instrução é usada para retornar os resultados da consulta SQL a seguir.

- `SELECT id, nome, preço FROM produtos WHERE preço > p_preco;`: Esta é a consulta SQL que seleciona todos os produtos com preços acima do valor passado como parâmetro.

Agora, podemos chamar essa função com valor de tabela para obter os produtos acima de um determinado preço. Por exemplo:

```sql
SELECT * FROM ProdutosAcimaDoPreco(15.00);
```

Isso retornaria:

| id  | nome      | preço |
|----|-----------|-------|
| 3  | Produto C | 20.00 |

Observe que a função `ProdutosAcimaDoPreco()` retorna uma tabela que pode ser usada como qualquer outra tabela em consultas SQL, permitindo que você faça consultas e operações adicionais com base nos resultados. Isso é útil quando você precisa encapsular consultas complexas ou gerar conjuntos de dados personalizados em suas consultas SQL.

Funções SQL com valor de tabela oferecem uma representação escalar que contém subelementos nomeados. São frequentemente usadas para funções orientadas a JSON e ARRAY, bem como funções como `generate_series()`. A função com valor de tabela é especificada na cláusula FROM e, em seguida, é referida como uma tabela, ou às vezes até como uma coluna. Funções desse formato são proeminentes no banco de dados PostgreSQL, embora algumas formas de funções com valor de tabela também sejam suportadas pelo SQLite, Oracle e SQL Server.

O SQLAlchemy fornece o método `FunctionElement.table_valued()` como a construção básica de "função com valor de tabela", que converterá um objeto `func` em uma cláusula FROM contendo uma série de colunas nomeadas, com base em nomes de string passados posicionamente. Isso retorna um objeto `TableValuedAlias`, que é uma construção de "Alias" habilitada para função que pode ser usada como qualquer outra cláusula FROM, conforme introduzido em "Usando Aliases". Abaixo, ilustramos a função `json_each()`, que, embora comum no PostgreSQL, também é suportada por versões modernas do SQLite:

```python	
onetwothree = func.json_each('["one", "two", "three"]').table_valued("value")
stmt = select(onetwothree).where(onetwothree.c.value.in_(["two", "three"]))
with engine.connect() as conn:
    result = conn.execute(stmt)
    result.all()
```

```python
[('two',), ('three',)]
```

```sql
SELECT 
    anon_1.value AS value
FROM
    json_each(:json_each_1) AS anon_1
WHERE 
    anon_1.value IN (:value_1, :value_2)
```

#### Funções com Valor de Coluna - Função com Valor de Tabela como Coluna Escalar

Uma sintaxe especial suportada pelo PostgreSQL e Oracle permite referenciar uma função na cláusula FROM, que então se entrega como uma única coluna na cláusula de colunas de uma instrução SELECT ou em outro contexto de expressão de coluna. O PostgreSQL faz grande uso dessa sintaxe para funções como `json_array_elements()`, `json_object_keys()`, `json_each_text()`, `json_each()`, entre outras.

O SQLAlchemy se refere a isso como uma "função com valor de coluna" e está disponível aplicando o modificador `FunctionElement.column_valued()` a uma construção de função:

```python
from sqlalchemy import select, func
stmt = select(func.json_array_elements('["one", "two"]').column_valued("x"))
print(stmt)
```

```sql
SELECT 
    x
FROM 
    json_array_elements(:json_array_elements_1) AS x
```

A forma "com valor de coluna" também é suportada pelo dialeto do Oracle, onde pode ser usada para funções SQL personalizadas:

```python
from sqlalchemy.dialects import oracle
stmt = select(func.scalar_strings(5).column_valued("s"))
print(stmt.compile(dialect=oracle.dialect()))
```

```sql
SELECT 
    s.COLUMN_VALUE
FROM
    TABLE(scalar_strings(:scalar_strings_1)) s
```

### Conversões de Dados e Coerção de Tipos

No SQL, frequentemente precisamos indicar explicitamente o tipo de dados de uma expressão, seja para informar ao banco de dados qual tipo é esperado em uma expressão de outra forma ambígua, ou em alguns casos quando desejamos converter o tipo de dados implícito de uma expressão SQL em algo diferente. A palavra-chave CAST do SQL é usada para essa tarefa, o que no SQLAlchemy é fornecido pela função `cast()`. Essa função aceita uma expressão de coluna e um objeto de tipo de dados como argumentos, como demonstrado abaixo, onde produzimos uma expressão SQL `CAST(user_account.id AS VARCHAR)` a partir do objeto de coluna `user_table.c.id`:

```python
from sqlalchemy import cast
stmt = select(cast(user_table.c.id, String))
with engine.connect() as conn:
    result = conn.execute(stmt)
    result.all()
```

```python
[('1',), ('2',), ('3',)]
```

```sql
SELECT 
    CAST(user_account.id AS VARCHAR) AS anon_1
FROM
    user_account
```

A função `cast()` não apenas gera a sintaxe SQL CAST, mas também produz uma expressão de coluna SQLAlchemy que atuará como o tipo de dados especificado no lado do Python também. Uma expressão de string que é `cast()` para JSON ganhará operadores de subscrito e comparação JSON, por exemplo:

```python
from sqlalchemy import JSON
print(cast("{'a': 'b'}", JSON)["a"])
```

```python
cast(:param_1 AS JSON).a
```

#### `type_coerce()` - um "cast" exclusivo do Python

Às vezes, há a necessidade de fazer com que o SQLAlchemy saiba o tipo de dados de uma expressão, por todas as razões mencionadas anteriormente, mas sem renderizar a expressão CAST propriamente dita no lado SQL, onde ela pode interferir com uma operação SQL que já funciona sem ela. Para esse caso de uso bastante comum, existe outra função chamada `type_coerce()`, que está intimamente relacionada com `cast()`, pois ela configura uma expressão em Python como tendo um tipo de dados específico no banco de dados SQL, mas não renderiza a palavra-chave CAST ou o tipo de dados no lado do banco de dados. `type_coerce()` é particularmente importante ao lidar com o tipo de dados JSON, que geralmente tem uma relação complexa com tipos de dados orientados a strings em diferentes plataformas e pode nem mesmo ser um tipo de dados explícito, como no SQLite e MariaDB. Abaixo, usamos `type_coerce()` para fornecer uma estrutura em Python como uma string JSON em uma das funções JSON do MySQL:

```python
import json
from sqlalchemy import JSON
from sqlalchemy import type_coerce
from sqlalchemy.dialects import mysql
s = select(type_coerce({"some_key": {"foo": "bar"}}, JSON)["some_key"])
print(s.compile(dialect=mysql.dialect()))
```

```sql
SELECT 
    json_extract(:param_1, :param_2) AS anon_1
```

No exemplo acima, a função SQL `JSON_EXTRACT` do MySQL foi invocada porque usamos `type_coerce()` para indicar que nosso dicionário Python deveria ser tratado como JSON. O operador Python `__getitem__`, `['alguma_chave']` neste caso, ficou disponível como resultado e permitiu que uma expressão de caminho `JSON_EXTRACT` (não mostrada, no entanto, neste caso, seria finalmente `'$."alguma_chave"'`) fosse renderizada.
